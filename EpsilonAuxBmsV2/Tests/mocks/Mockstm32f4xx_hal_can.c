/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockstm32f4xx_hal_can.h"

static const char* CMockString_ActiveITs = "ActiveITs";
static const char* CMockString_CallbackID = "CallbackID";
static const char* CMockString_HAL_CAN_AbortTxRequest = "HAL_CAN_AbortTxRequest";
static const char* CMockString_HAL_CAN_ActivateNotification = "HAL_CAN_ActivateNotification";
static const char* CMockString_HAL_CAN_AddTxMessage = "HAL_CAN_AddTxMessage";
static const char* CMockString_HAL_CAN_ConfigFilter = "HAL_CAN_ConfigFilter";
static const char* CMockString_HAL_CAN_DeInit = "HAL_CAN_DeInit";
static const char* CMockString_HAL_CAN_DeactivateNotification = "HAL_CAN_DeactivateNotification";
static const char* CMockString_HAL_CAN_ErrorCallback = "HAL_CAN_ErrorCallback";
static const char* CMockString_HAL_CAN_GetError = "HAL_CAN_GetError";
static const char* CMockString_HAL_CAN_GetRxFifoFillLevel = "HAL_CAN_GetRxFifoFillLevel";
static const char* CMockString_HAL_CAN_GetRxMessage = "HAL_CAN_GetRxMessage";
static const char* CMockString_HAL_CAN_GetState = "HAL_CAN_GetState";
static const char* CMockString_HAL_CAN_GetTxMailboxesFreeLevel = "HAL_CAN_GetTxMailboxesFreeLevel";
static const char* CMockString_HAL_CAN_GetTxTimestamp = "HAL_CAN_GetTxTimestamp";
static const char* CMockString_HAL_CAN_IRQHandler = "HAL_CAN_IRQHandler";
static const char* CMockString_HAL_CAN_Init = "HAL_CAN_Init";
static const char* CMockString_HAL_CAN_IsSleepActive = "HAL_CAN_IsSleepActive";
static const char* CMockString_HAL_CAN_IsTxMessagePending = "HAL_CAN_IsTxMessagePending";
static const char* CMockString_HAL_CAN_MspDeInit = "HAL_CAN_MspDeInit";
static const char* CMockString_HAL_CAN_MspInit = "HAL_CAN_MspInit";
static const char* CMockString_HAL_CAN_RegisterCallback = "HAL_CAN_RegisterCallback";
static const char* CMockString_HAL_CAN_RequestSleep = "HAL_CAN_RequestSleep";
static const char* CMockString_HAL_CAN_ResetError = "HAL_CAN_ResetError";
static const char* CMockString_HAL_CAN_RxFifo0FullCallback = "HAL_CAN_RxFifo0FullCallback";
static const char* CMockString_HAL_CAN_RxFifo0MsgPendingCallback = "HAL_CAN_RxFifo0MsgPendingCallback";
static const char* CMockString_HAL_CAN_RxFifo1FullCallback = "HAL_CAN_RxFifo1FullCallback";
static const char* CMockString_HAL_CAN_RxFifo1MsgPendingCallback = "HAL_CAN_RxFifo1MsgPendingCallback";
static const char* CMockString_HAL_CAN_SleepCallback = "HAL_CAN_SleepCallback";
static const char* CMockString_HAL_CAN_Start = "HAL_CAN_Start";
static const char* CMockString_HAL_CAN_Stop = "HAL_CAN_Stop";
static const char* CMockString_HAL_CAN_TxMailbox0AbortCallback = "HAL_CAN_TxMailbox0AbortCallback";
static const char* CMockString_HAL_CAN_TxMailbox0CompleteCallback = "HAL_CAN_TxMailbox0CompleteCallback";
static const char* CMockString_HAL_CAN_TxMailbox1AbortCallback = "HAL_CAN_TxMailbox1AbortCallback";
static const char* CMockString_HAL_CAN_TxMailbox1CompleteCallback = "HAL_CAN_TxMailbox1CompleteCallback";
static const char* CMockString_HAL_CAN_TxMailbox2AbortCallback = "HAL_CAN_TxMailbox2AbortCallback";
static const char* CMockString_HAL_CAN_TxMailbox2CompleteCallback = "HAL_CAN_TxMailbox2CompleteCallback";
static const char* CMockString_HAL_CAN_UnRegisterCallback = "HAL_CAN_UnRegisterCallback";
static const char* CMockString_HAL_CAN_WakeUp = "HAL_CAN_WakeUp";
static const char* CMockString_HAL_CAN_WakeUpFromRxMsgCallback = "HAL_CAN_WakeUpFromRxMsgCallback";
static const char* CMockString_InactiveITs = "InactiveITs";
static const char* CMockString_RxFifo = "RxFifo";
static const char* CMockString_TxMailbox = "TxMailbox";
static const char* CMockString_TxMailboxes = "TxMailboxes";
static const char* CMockString_aData = "aData";
static const char* CMockString_hcan = "hcan";
static const char* CMockString_pCallback = "pCallback";
static const char* CMockString_pHeader = "pHeader";
static const char* CMockString_pTxMailbox = "pTxMailbox";
static const char* CMockString_sFilterConfig = "sFilterConfig";

typedef struct _CMOCK_HAL_CAN_Init_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_Init_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_DeInit_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_DeInit_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_MspInit_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_MspInit_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    HAL_CAN_CallbackIDTypeDef Expected_CallbackID;
    cmock_stm32f4xx_hal_can_func_ptr1 Expected_pCallback;

} CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    HAL_CAN_CallbackIDTypeDef Expected_CallbackID;

} CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    CAN_FilterTypeDef* Expected_sFilterConfig;

} CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_Start_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_Start_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_Stop_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_Stop_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    CAN_TxHeaderTypeDef* Expected_pHeader;
    uint8_t* Expected_aData;
    uint32_t* Expected_pTxMailbox;

} CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_TxMailboxes;

} CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_TxMailboxes;

} CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_TxMailbox;

} CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_RxFifo;
    CAN_RxHeaderTypeDef* Expected_pHeader;
    uint8_t* Expected_aData;

} CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_RxFifo;

} CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_ActiveITs;

} CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;
    uint32_t Expected_InactiveITs;

} CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetState_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_CAN_StateTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_GetState_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_GetError_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_GetError_CALL_INSTANCE;

typedef struct _CMOCK_HAL_CAN_ResetError_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    HAL_StatusTypeDef ReturnVal;
    CAN_HandleTypeDef* Expected_hcan;

} CMOCK_HAL_CAN_ResetError_CALL_INSTANCE;

static struct Mockstm32f4xx_hal_canInstance
{
    CMOCK_MEM_INDEX_TYPE HAL_CAN_Init_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_DeInit_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_MspInit_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_MspDeInit_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RegisterCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_UnRegisterCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_ConfigFilter_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_Start_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_Stop_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RequestSleep_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_WakeUp_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_IsSleepActive_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_AddTxMessage_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_AbortTxRequest_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetTxMailboxesFreeLevel_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_IsTxMessagePending_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetTxTimestamp_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetRxMessage_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetRxFifoFillLevel_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_ActivateNotification_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_DeactivateNotification_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_IRQHandler_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox0CompleteCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox1CompleteCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox2CompleteCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox0AbortCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox1AbortCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_TxMailbox2AbortCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RxFifo0MsgPendingCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RxFifo0FullCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RxFifo1MsgPendingCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_RxFifo1FullCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_SleepCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_WakeUpFromRxMsgCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_ErrorCallback_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetState_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_GetError_CallInstance;
    CMOCK_MEM_INDEX_TYPE HAL_CAN_ResetError_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockstm32f4xx_hal_can_Verify(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_MEM_INDEX_TYPE call_instance;
    call_instance = Mock.HAL_CAN_Init_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_Init);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_DeInit_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_DeInit);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_MspInit_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_MspInit);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_MspDeInit_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_MspDeInit);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RegisterCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RegisterCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_UnRegisterCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_UnRegisterCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_ConfigFilter_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_ConfigFilter);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_Start_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_Start);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_Stop_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_Stop);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RequestSleep_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RequestSleep);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_WakeUp_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_WakeUp);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_IsSleepActive_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_IsSleepActive);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_AddTxMessage_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_AddTxMessage);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_AbortTxRequest_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_AbortTxRequest);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetTxMailboxesFreeLevel);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_IsTxMessagePending_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_IsTxMessagePending);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetTxTimestamp_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetTxTimestamp);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetRxMessage_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetRxMessage);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetRxFifoFillLevel);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_ActivateNotification_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_ActivateNotification);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_DeactivateNotification_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_DeactivateNotification);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_IRQHandler_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_IRQHandler);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox0CompleteCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox1CompleteCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox2CompleteCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox0AbortCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox1AbortCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox2AbortCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo0MsgPendingCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RxFifo0FullCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo0FullCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo1MsgPendingCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_RxFifo1FullCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo1FullCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_SleepCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_SleepCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_WakeUpFromRxMsgCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_ErrorCallback_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_ErrorCallback);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetState_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetState);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_GetError_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_GetError);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.HAL_CAN_ResetError_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_HAL_CAN_ResetError);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }
}

void Mockstm32f4xx_hal_can_Init(void)
{
    Mockstm32f4xx_hal_can_Destroy();
}

void Mockstm32f4xx_hal_can_Destroy(void)
{
    CMock_Guts_MemFreeAll();
    memset(&Mock, 0, sizeof(Mock));
}

HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_Init_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_Init);
    cmock_call_instance = (CMOCK_HAL_CAN_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_Init_CallInstance);
    Mock.HAL_CAN_Init_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_Init_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_Init, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_Init(CMOCK_HAL_CAN_Init_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_Init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_Init_CALL_INSTANCE));
    CMOCK_HAL_CAN_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_Init_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_Init_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_Init(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_DeInit_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_DeInit);
    cmock_call_instance = (CMOCK_HAL_CAN_DeInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_DeInit_CallInstance);
    Mock.HAL_CAN_DeInit_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_DeInit_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_DeInit, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_DeInit(CMOCK_HAL_CAN_DeInit_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_DeInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_DeInit_CALL_INSTANCE));
    CMOCK_HAL_CAN_DeInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_DeInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_DeInit_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_DeInit_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_DeInit(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_MspInit_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_MspInit);
    cmock_call_instance = (CMOCK_HAL_CAN_MspInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_MspInit_CallInstance);
    Mock.HAL_CAN_MspInit_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_MspInit_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_MspInit, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_MspInit(CMOCK_HAL_CAN_MspInit_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_MspInit_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_MspInit_CALL_INSTANCE));
    CMOCK_HAL_CAN_MspInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_MspInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_MspInit_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_MspInit_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_MspInit(cmock_call_instance, hcan);
}

void HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_MspDeInit);
    cmock_call_instance = (CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_MspDeInit_CallInstance);
    Mock.HAL_CAN_MspDeInit_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_MspDeInit_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_MspDeInit, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_MspDeInit(CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_MspDeInit_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE));
    CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_MspDeInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_MspDeInit_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_MspDeInit_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_MspDeInit(cmock_call_instance, hcan);
}

HAL_StatusTypeDef HAL_CAN_RegisterCallback(CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID, cmock_stm32f4xx_hal_can_func_ptr1 pCallback)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RegisterCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RegisterCallback_CallInstance);
    Mock.HAL_CAN_RegisterCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RegisterCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RegisterCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RegisterCallback, CMockString_CallbackID);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_CallbackID), (void*)(&CallbackID), sizeof(HAL_CAN_CallbackIDTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RegisterCallback, CMockString_pCallback);
        UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pCallback, pCallback, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_RegisterCallback(CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID, cmock_stm32f4xx_hal_can_func_ptr1 pCallback)
{
    cmock_call_instance->Expected_hcan = hcan;
    memcpy((void*)(&cmock_call_instance->Expected_CallbackID), (void*)(&CallbackID),
           sizeof(HAL_CAN_CallbackIDTypeDef[sizeof(CallbackID) == sizeof(HAL_CAN_CallbackIDTypeDef) ? 1 : -1])); /* add HAL_CAN_CallbackIDTypeDef to :treat_as_array if this causes an error */
    memcpy((void*)(&cmock_call_instance->Expected_pCallback), (void*)(&pCallback),
           sizeof(cmock_stm32f4xx_hal_can_func_ptr1[sizeof(pCallback) == sizeof(cmock_stm32f4xx_hal_can_func_ptr1) ? 1 : -1])); /* add cmock_stm32f4xx_hal_can_func_ptr1 to :treat_as_array if this causes an error */
}

void HAL_CAN_RegisterCallback_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID, cmock_stm32f4xx_hal_can_func_ptr1 pCallback, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RegisterCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RegisterCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RegisterCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RegisterCallback(cmock_call_instance, hcan, CallbackID, pCallback);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_UnRegisterCallback(CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_UnRegisterCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_UnRegisterCallback_CallInstance);
    Mock.HAL_CAN_UnRegisterCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_UnRegisterCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_UnRegisterCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_UnRegisterCallback, CMockString_CallbackID);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_CallbackID), (void*)(&CallbackID), sizeof(HAL_CAN_CallbackIDTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_UnRegisterCallback(CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID)
{
    cmock_call_instance->Expected_hcan = hcan;
    memcpy((void*)(&cmock_call_instance->Expected_CallbackID), (void*)(&CallbackID),
           sizeof(HAL_CAN_CallbackIDTypeDef[sizeof(CallbackID) == sizeof(HAL_CAN_CallbackIDTypeDef) ? 1 : -1])); /* add HAL_CAN_CallbackIDTypeDef to :treat_as_array if this causes an error */
}

void HAL_CAN_UnRegisterCallback_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_CAN_CallbackIDTypeDef CallbackID, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_UnRegisterCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_UnRegisterCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_UnRegisterCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_UnRegisterCallback(cmock_call_instance, hcan, CallbackID);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterTypeDef* sFilterConfig)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_ConfigFilter);
    cmock_call_instance = (CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_ConfigFilter_CallInstance);
    Mock.HAL_CAN_ConfigFilter_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_ConfigFilter_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ConfigFilter, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ConfigFilter, CMockString_sFilterConfig);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_sFilterConfig), (void*)(sFilterConfig), sizeof(CAN_FilterTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_ConfigFilter(CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, CAN_FilterTypeDef* sFilterConfig)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_sFilterConfig = sFilterConfig;
}

void HAL_CAN_ConfigFilter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, CAN_FilterTypeDef* sFilterConfig, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE));
    CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_ConfigFilter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_ConfigFilter_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_ConfigFilter_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_ConfigFilter(cmock_call_instance, hcan, sFilterConfig);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_Start_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_Start);
    cmock_call_instance = (CMOCK_HAL_CAN_Start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_Start_CallInstance);
    Mock.HAL_CAN_Start_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_Start_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_Start, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_Start(CMOCK_HAL_CAN_Start_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_Start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_Start_CALL_INSTANCE));
    CMOCK_HAL_CAN_Start_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_Start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_Start_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_Start_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_Start(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_Stop_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_Stop);
    cmock_call_instance = (CMOCK_HAL_CAN_Stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_Stop_CallInstance);
    Mock.HAL_CAN_Stop_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_Stop_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_Stop, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_Stop(CMOCK_HAL_CAN_Stop_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_Stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_Stop_CALL_INSTANCE));
    CMOCK_HAL_CAN_Stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_Stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_Stop_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_Stop_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_Stop(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RequestSleep);
    cmock_call_instance = (CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RequestSleep_CallInstance);
    Mock.HAL_CAN_RequestSleep_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RequestSleep_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RequestSleep, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_RequestSleep(CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_RequestSleep_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE));
    CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RequestSleep_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RequestSleep_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RequestSleep_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RequestSleep(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_WakeUp);
    cmock_call_instance = (CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_WakeUp_CallInstance);
    Mock.HAL_CAN_WakeUp_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_WakeUp_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_WakeUp, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_WakeUp(CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_WakeUp_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE));
    CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_WakeUp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_WakeUp_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_WakeUp_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_WakeUp(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

uint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_IsSleepActive);
    cmock_call_instance = (CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_IsSleepActive_CallInstance);
    Mock.HAL_CAN_IsSleepActive_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_IsSleepActive_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_IsSleepActive, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_IsSleepActive(CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_IsSleepActive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE));
    CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_IsSleepActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_IsSleepActive_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_IsSleepActive_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_IsSleepActive(cmock_call_instance, hcan);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef* hcan, CAN_TxHeaderTypeDef* pHeader, uint8_t* aData, uint32_t* pTxMailbox)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_AddTxMessage);
    cmock_call_instance = (CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_AddTxMessage_CallInstance);
    Mock.HAL_CAN_AddTxMessage_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_AddTxMessage_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AddTxMessage, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AddTxMessage, CMockString_pHeader);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pHeader), (void*)(pHeader), sizeof(CAN_TxHeaderTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AddTxMessage, CMockString_aData);

        if (cmock_call_instance->Expected_aData == NULL)
        {
            UNITY_TEST_ASSERT_NULL(aData, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_aData, aData, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AddTxMessage, CMockString_pTxMailbox);

        if (cmock_call_instance->Expected_pTxMailbox == NULL)
        {
            UNITY_TEST_ASSERT_NULL(pTxMailbox, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pTxMailbox, pTxMailbox, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_AddTxMessage(CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, CAN_TxHeaderTypeDef* pHeader, uint8_t* aData, uint32_t* pTxMailbox)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_pHeader = pHeader;
    cmock_call_instance->Expected_aData = aData;
    cmock_call_instance->Expected_pTxMailbox = pTxMailbox;
}

void HAL_CAN_AddTxMessage_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, CAN_TxHeaderTypeDef* pHeader, uint8_t* aData, uint32_t* pTxMailbox, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE));
    CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_AddTxMessage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_AddTxMessage_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_AddTxMessage_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_AddTxMessage(cmock_call_instance, hcan, pHeader, aData, pTxMailbox);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef* hcan, uint32_t TxMailboxes)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_AbortTxRequest);
    cmock_call_instance = (CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_AbortTxRequest_CallInstance);
    Mock.HAL_CAN_AbortTxRequest_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_AbortTxRequest_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AbortTxRequest, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_AbortTxRequest, CMockString_TxMailboxes);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_TxMailboxes, TxMailboxes, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_AbortTxRequest(CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t TxMailboxes)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_TxMailboxes = TxMailboxes;
}

void HAL_CAN_AbortTxRequest_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t TxMailboxes, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE));
    CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_AbortTxRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_AbortTxRequest_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_AbortTxRequest_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_AbortTxRequest(cmock_call_instance, hcan, TxMailboxes);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

uint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetTxMailboxesFreeLevel);
    cmock_call_instance = (CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance);
    Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetTxMailboxesFreeLevel, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetTxMailboxesFreeLevel(CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_GetTxMailboxesFreeLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetTxMailboxesFreeLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetTxMailboxesFreeLevel_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetTxMailboxesFreeLevel(cmock_call_instance, hcan);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef* hcan, uint32_t TxMailboxes)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_IsTxMessagePending);
    cmock_call_instance = (CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_IsTxMessagePending_CallInstance);
    Mock.HAL_CAN_IsTxMessagePending_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_IsTxMessagePending_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_IsTxMessagePending, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_IsTxMessagePending, CMockString_TxMailboxes);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_TxMailboxes, TxMailboxes, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_IsTxMessagePending(CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t TxMailboxes)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_TxMailboxes = TxMailboxes;
}

void HAL_CAN_IsTxMessagePending_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t TxMailboxes, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE));
    CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_IsTxMessagePending_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_IsTxMessagePending_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_IsTxMessagePending_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_IsTxMessagePending(cmock_call_instance, hcan, TxMailboxes);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef* hcan, uint32_t TxMailbox)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetTxTimestamp);
    cmock_call_instance = (CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetTxTimestamp_CallInstance);
    Mock.HAL_CAN_GetTxTimestamp_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetTxTimestamp_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetTxTimestamp, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetTxTimestamp, CMockString_TxMailbox);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_TxMailbox, TxMailbox, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetTxTimestamp(CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t TxMailbox)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_TxMailbox = TxMailbox;
}

void HAL_CAN_GetTxTimestamp_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t TxMailbox, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetTxTimestamp_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetTxTimestamp_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetTxTimestamp_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetTxTimestamp(cmock_call_instance, hcan, TxMailbox);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef* hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef* pHeader, uint8_t* aData)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetRxMessage);
    cmock_call_instance = (CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetRxMessage_CallInstance);
    Mock.HAL_CAN_GetRxMessage_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetRxMessage_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxMessage, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxMessage, CMockString_RxFifo);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_RxFifo, RxFifo, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxMessage, CMockString_pHeader);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pHeader), (void*)(pHeader), sizeof(CAN_RxHeaderTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxMessage, CMockString_aData);

        if (cmock_call_instance->Expected_aData == NULL)
        {
            UNITY_TEST_ASSERT_NULL(aData, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_aData, aData, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetRxMessage(CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef* pHeader, uint8_t* aData)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_RxFifo = RxFifo;
    cmock_call_instance->Expected_pHeader = pHeader;
    cmock_call_instance->Expected_aData = aData;
}

void HAL_CAN_GetRxMessage_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef* pHeader, uint8_t* aData, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetRxMessage_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetRxMessage_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetRxMessage_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetRxMessage(cmock_call_instance, hcan, RxFifo, pHeader, aData);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

uint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef* hcan, uint32_t RxFifo)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetRxFifoFillLevel);
    cmock_call_instance = (CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance);
    Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxFifoFillLevel, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetRxFifoFillLevel, CMockString_RxFifo);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_RxFifo, RxFifo, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetRxFifoFillLevel(CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t RxFifo)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_RxFifo = RxFifo;
}

void HAL_CAN_GetRxFifoFillLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t RxFifo, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetRxFifoFillLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetRxFifoFillLevel_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetRxFifoFillLevel(cmock_call_instance, hcan, RxFifo);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef* hcan, uint32_t ActiveITs)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_ActivateNotification);
    cmock_call_instance = (CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_ActivateNotification_CallInstance);
    Mock.HAL_CAN_ActivateNotification_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_ActivateNotification_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ActivateNotification, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ActivateNotification, CMockString_ActiveITs);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ActiveITs, ActiveITs, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_ActivateNotification(CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t ActiveITs)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_ActiveITs = ActiveITs;
}

void HAL_CAN_ActivateNotification_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t ActiveITs, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE));
    CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_ActivateNotification_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_ActivateNotification_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_ActivateNotification_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_ActivateNotification(cmock_call_instance, hcan, ActiveITs);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

HAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef* hcan, uint32_t InactiveITs)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_DeactivateNotification);
    cmock_call_instance = (CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_DeactivateNotification_CallInstance);
    Mock.HAL_CAN_DeactivateNotification_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_DeactivateNotification_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_DeactivateNotification, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_DeactivateNotification, CMockString_InactiveITs);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_InactiveITs, InactiveITs, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_DeactivateNotification(CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan, uint32_t InactiveITs)
{
    cmock_call_instance->Expected_hcan = hcan;
    cmock_call_instance->Expected_InactiveITs = InactiveITs;
}

void HAL_CAN_DeactivateNotification_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t InactiveITs, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE));
    CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_DeactivateNotification_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_DeactivateNotification_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_DeactivateNotification_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_DeactivateNotification(cmock_call_instance, hcan, InactiveITs);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_IRQHandler);
    cmock_call_instance = (CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_IRQHandler_CallInstance);
    Mock.HAL_CAN_IRQHandler_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_IRQHandler_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_IRQHandler, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_IRQHandler(CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_IRQHandler_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE));
    CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_IRQHandler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_IRQHandler_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_IRQHandler_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_IRQHandler(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox0CompleteCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox0CompleteCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox0CompleteCallback(CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox0CompleteCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox0CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox0CompleteCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox0CompleteCallback(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox1CompleteCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox1CompleteCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox1CompleteCallback(CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox1CompleteCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox1CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox1CompleteCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox1CompleteCallback(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox2CompleteCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox2CompleteCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox2CompleteCallback(CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox2CompleteCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox2CompleteCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox2CompleteCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox2CompleteCallback(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox0AbortCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox0AbortCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox0AbortCallback(CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox0AbortCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox0AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox0AbortCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox0AbortCallback(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox1AbortCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox1AbortCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox1AbortCallback(CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox1AbortCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox1AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox1AbortCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox1AbortCallback(cmock_call_instance, hcan);
}

void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_TxMailbox2AbortCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance);
    Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_TxMailbox2AbortCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_TxMailbox2AbortCallback(CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_TxMailbox2AbortCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_TxMailbox2AbortCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_TxMailbox2AbortCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_TxMailbox2AbortCallback(cmock_call_instance, hcan);
}

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo0MsgPendingCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance);
    Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RxFifo0MsgPendingCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_RxFifo0MsgPendingCallback(CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_RxFifo0MsgPendingCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RxFifo0MsgPendingCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RxFifo0MsgPendingCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RxFifo0MsgPendingCallback(cmock_call_instance, hcan);
}

void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo0FullCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RxFifo0FullCallback_CallInstance);
    Mock.HAL_CAN_RxFifo0FullCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RxFifo0FullCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RxFifo0FullCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_RxFifo0FullCallback(CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_RxFifo0FullCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RxFifo0FullCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RxFifo0FullCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RxFifo0FullCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RxFifo0FullCallback(cmock_call_instance, hcan);
}

void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo1MsgPendingCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance);
    Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RxFifo1MsgPendingCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_RxFifo1MsgPendingCallback(CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_RxFifo1MsgPendingCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RxFifo1MsgPendingCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RxFifo1MsgPendingCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RxFifo1MsgPendingCallback(cmock_call_instance, hcan);
}

void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_RxFifo1FullCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_RxFifo1FullCallback_CallInstance);
    Mock.HAL_CAN_RxFifo1FullCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_RxFifo1FullCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_RxFifo1FullCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_RxFifo1FullCallback(CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_RxFifo1FullCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_RxFifo1FullCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_RxFifo1FullCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_RxFifo1FullCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_RxFifo1FullCallback(cmock_call_instance, hcan);
}

void HAL_CAN_SleepCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_SleepCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_SleepCallback_CallInstance);
    Mock.HAL_CAN_SleepCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_SleepCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_SleepCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_SleepCallback(CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_SleepCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_SleepCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_SleepCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_SleepCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_SleepCallback(cmock_call_instance, hcan);
}

void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_WakeUpFromRxMsgCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance);
    Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_WakeUpFromRxMsgCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_WakeUpFromRxMsgCallback(CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_WakeUpFromRxMsgCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_WakeUpFromRxMsgCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_WakeUpFromRxMsgCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_WakeUpFromRxMsgCallback(cmock_call_instance, hcan);
}

void HAL_CAN_ErrorCallback(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_ErrorCallback);
    cmock_call_instance = (CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_ErrorCallback_CallInstance);
    Mock.HAL_CAN_ErrorCallback_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_ErrorCallback_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ErrorCallback, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_HAL_CAN_ErrorCallback(CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_ErrorCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE));
    CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_ErrorCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_ErrorCallback_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_ErrorCallback_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_ErrorCallback(cmock_call_instance, hcan);
}

HAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetState_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetState);
    cmock_call_instance = (CMOCK_HAL_CAN_GetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetState_CallInstance);
    Mock.HAL_CAN_GetState_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetState_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetState, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetState(CMOCK_HAL_CAN_GetState_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_GetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_CAN_StateTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetState_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetState_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetState_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetState(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_CAN_StateTypeDef[sizeof(cmock_to_return) == sizeof(HAL_CAN_StateTypeDef) ? 1 : -1])); /* add HAL_CAN_StateTypeDef to :treat_as_array if this causes an error */
}

uint32_t HAL_CAN_GetError(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_GetError_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_GetError);
    cmock_call_instance = (CMOCK_HAL_CAN_GetError_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_GetError_CallInstance);
    Mock.HAL_CAN_GetError_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_GetError_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_GetError, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_GetError(CMOCK_HAL_CAN_GetError_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_GetError_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_GetError_CALL_INSTANCE));
    CMOCK_HAL_CAN_GetError_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_GetError_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_GetError_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_GetError_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_GetError(cmock_call_instance, hcan);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef* hcan)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_HAL_CAN_ResetError_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_HAL_CAN_ResetError);
    cmock_call_instance = (CMOCK_HAL_CAN_ResetError_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.HAL_CAN_ResetError_CallInstance);
    Mock.HAL_CAN_ResetError_CallInstance = CMock_Guts_MemNext(Mock.HAL_CAN_ResetError_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_HAL_CAN_ResetError, CMockString_hcan);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hcan), (void*)(hcan), sizeof(CAN_HandleTypeDef), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_HAL_CAN_ResetError(CMOCK_HAL_CAN_ResetError_CALL_INSTANCE* cmock_call_instance, CAN_HandleTypeDef* hcan)
{
    cmock_call_instance->Expected_hcan = hcan;
}

void HAL_CAN_ResetError_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, CAN_HandleTypeDef* hcan, HAL_StatusTypeDef cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_HAL_CAN_ResetError_CALL_INSTANCE));
    CMOCK_HAL_CAN_ResetError_CALL_INSTANCE* cmock_call_instance = (CMOCK_HAL_CAN_ResetError_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.HAL_CAN_ResetError_CallInstance = CMock_Guts_MemChain(Mock.HAL_CAN_ResetError_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_HAL_CAN_ResetError(cmock_call_instance, hcan);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(HAL_StatusTypeDef[sizeof(cmock_to_return) == sizeof(HAL_StatusTypeDef) ? 1 : -1])); /* add HAL_StatusTypeDef to :treat_as_array if this causes an error */
}

