/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockcmsis_os2.h"

static const char* CMockString_argument = "argument";
static const char* CMockString_array_items = "array_items";
static const char* CMockString_attr = "attr";
static const char* CMockString_block = "block";
static const char* CMockString_block_count = "block_count";
static const char* CMockString_block_size = "block_size";
static const char* CMockString_ef_id = "ef_id";
static const char* CMockString_flags = "flags";
static const char* CMockString_func = "func";
static const char* CMockString_id_buf = "id_buf";
static const char* CMockString_id_size = "id_size";
static const char* CMockString_initial_count = "initial_count";
static const char* CMockString_lock = "lock";
static const char* CMockString_max_count = "max_count";
static const char* CMockString_mp_id = "mp_id";
static const char* CMockString_mq_id = "mq_id";
static const char* CMockString_msg_count = "msg_count";
static const char* CMockString_msg_prio = "msg_prio";
static const char* CMockString_msg_ptr = "msg_ptr";
static const char* CMockString_msg_size = "msg_size";
static const char* CMockString_mutex_id = "mutex_id";
static const char* CMockString_options = "options";
static const char* CMockString_osDelay = "osDelay";
static const char* CMockString_osDelayUntil = "osDelayUntil";
static const char* CMockString_osEventFlagsClear = "osEventFlagsClear";
static const char* CMockString_osEventFlagsDelete = "osEventFlagsDelete";
static const char* CMockString_osEventFlagsGet = "osEventFlagsGet";
static const char* CMockString_osEventFlagsGetName = "osEventFlagsGetName";
static const char* CMockString_osEventFlagsNew = "osEventFlagsNew";
static const char* CMockString_osEventFlagsSet = "osEventFlagsSet";
static const char* CMockString_osEventFlagsWait = "osEventFlagsWait";
static const char* CMockString_osKernelGetInfo = "osKernelGetInfo";
static const char* CMockString_osKernelGetState = "osKernelGetState";
static const char* CMockString_osKernelGetSysTimerCount = "osKernelGetSysTimerCount";
static const char* CMockString_osKernelGetSysTimerFreq = "osKernelGetSysTimerFreq";
static const char* CMockString_osKernelGetTickCount = "osKernelGetTickCount";
static const char* CMockString_osKernelGetTickFreq = "osKernelGetTickFreq";
static const char* CMockString_osKernelInitialize = "osKernelInitialize";
static const char* CMockString_osKernelLock = "osKernelLock";
static const char* CMockString_osKernelRestoreLock = "osKernelRestoreLock";
static const char* CMockString_osKernelResume = "osKernelResume";
static const char* CMockString_osKernelStart = "osKernelStart";
static const char* CMockString_osKernelSuspend = "osKernelSuspend";
static const char* CMockString_osKernelUnlock = "osKernelUnlock";
static const char* CMockString_osMemoryPoolAlloc = "osMemoryPoolAlloc";
static const char* CMockString_osMemoryPoolDelete = "osMemoryPoolDelete";
static const char* CMockString_osMemoryPoolFree = "osMemoryPoolFree";
static const char* CMockString_osMemoryPoolGetBlockSize = "osMemoryPoolGetBlockSize";
static const char* CMockString_osMemoryPoolGetCapacity = "osMemoryPoolGetCapacity";
static const char* CMockString_osMemoryPoolGetCount = "osMemoryPoolGetCount";
static const char* CMockString_osMemoryPoolGetName = "osMemoryPoolGetName";
static const char* CMockString_osMemoryPoolGetSpace = "osMemoryPoolGetSpace";
static const char* CMockString_osMemoryPoolNew = "osMemoryPoolNew";
static const char* CMockString_osMessageQueueDelete = "osMessageQueueDelete";
static const char* CMockString_osMessageQueueGet = "osMessageQueueGet";
static const char* CMockString_osMessageQueueGetCapacity = "osMessageQueueGetCapacity";
static const char* CMockString_osMessageQueueGetCount = "osMessageQueueGetCount";
static const char* CMockString_osMessageQueueGetMsgSize = "osMessageQueueGetMsgSize";
static const char* CMockString_osMessageQueueGetName = "osMessageQueueGetName";
static const char* CMockString_osMessageQueueGetSpace = "osMessageQueueGetSpace";
static const char* CMockString_osMessageQueueNew = "osMessageQueueNew";
static const char* CMockString_osMessageQueuePut = "osMessageQueuePut";
static const char* CMockString_osMessageQueueReset = "osMessageQueueReset";
static const char* CMockString_osMutexAcquire = "osMutexAcquire";
static const char* CMockString_osMutexDelete = "osMutexDelete";
static const char* CMockString_osMutexGetName = "osMutexGetName";
static const char* CMockString_osMutexGetOwner = "osMutexGetOwner";
static const char* CMockString_osMutexNew = "osMutexNew";
static const char* CMockString_osMutexRelease = "osMutexRelease";
static const char* CMockString_osSemaphoreAcquire = "osSemaphoreAcquire";
static const char* CMockString_osSemaphoreDelete = "osSemaphoreDelete";
static const char* CMockString_osSemaphoreGetCount = "osSemaphoreGetCount";
static const char* CMockString_osSemaphoreGetName = "osSemaphoreGetName";
static const char* CMockString_osSemaphoreNew = "osSemaphoreNew";
static const char* CMockString_osSemaphoreRelease = "osSemaphoreRelease";
static const char* CMockString_osThreadDetach = "osThreadDetach";
static const char* CMockString_osThreadEnumerate = "osThreadEnumerate";
static const char* CMockString_osThreadExit = "osThreadExit";
static const char* CMockString_osThreadFlagsClear = "osThreadFlagsClear";
static const char* CMockString_osThreadFlagsGet = "osThreadFlagsGet";
static const char* CMockString_osThreadFlagsSet = "osThreadFlagsSet";
static const char* CMockString_osThreadFlagsWait = "osThreadFlagsWait";
static const char* CMockString_osThreadGetCount = "osThreadGetCount";
static const char* CMockString_osThreadGetId = "osThreadGetId";
static const char* CMockString_osThreadGetName = "osThreadGetName";
static const char* CMockString_osThreadGetPriority = "osThreadGetPriority";
static const char* CMockString_osThreadGetStackSize = "osThreadGetStackSize";
static const char* CMockString_osThreadGetStackSpace = "osThreadGetStackSpace";
static const char* CMockString_osThreadGetState = "osThreadGetState";
static const char* CMockString_osThreadJoin = "osThreadJoin";
static const char* CMockString_osThreadNew = "osThreadNew";
static const char* CMockString_osThreadResume = "osThreadResume";
static const char* CMockString_osThreadSetPriority = "osThreadSetPriority";
static const char* CMockString_osThreadSuspend = "osThreadSuspend";
static const char* CMockString_osThreadTerminate = "osThreadTerminate";
static const char* CMockString_osThreadYield = "osThreadYield";
static const char* CMockString_osTimerDelete = "osTimerDelete";
static const char* CMockString_osTimerGetName = "osTimerGetName";
static const char* CMockString_osTimerIsRunning = "osTimerIsRunning";
static const char* CMockString_osTimerNew = "osTimerNew";
static const char* CMockString_osTimerStart = "osTimerStart";
static const char* CMockString_osTimerStop = "osTimerStop";
static const char* CMockString_priority = "priority";
static const char* CMockString_semaphore_id = "semaphore_id";
static const char* CMockString_sleep_ticks = "sleep_ticks";
static const char* CMockString_thread_array = "thread_array";
static const char* CMockString_thread_id = "thread_id";
static const char* CMockString_ticks = "ticks";
static const char* CMockString_timeout = "timeout";
static const char* CMockString_timer_id = "timer_id";
static const char* CMockString_type = "type";
static const char* CMockString_version = "version";

typedef struct _CMOCK_osKernelInitialize_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;

} CMOCK_osKernelInitialize_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetInfo_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osVersion_t* Expected_version;
    char* Expected_id_buf;
    uint32_t Expected_id_size;

} CMOCK_osKernelGetInfo_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetState_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osKernelState_t ReturnVal;

} CMOCK_osKernelGetState_CALL_INSTANCE;

typedef struct _CMOCK_osKernelStart_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;

} CMOCK_osKernelStart_CALL_INSTANCE;

typedef struct _CMOCK_osKernelLock_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;

} CMOCK_osKernelLock_CALL_INSTANCE;

typedef struct _CMOCK_osKernelUnlock_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;

} CMOCK_osKernelUnlock_CALL_INSTANCE;

typedef struct _CMOCK_osKernelRestoreLock_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;
    int32_t Expected_lock;

} CMOCK_osKernelRestoreLock_CALL_INSTANCE;

typedef struct _CMOCK_osKernelSuspend_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelSuspend_CALL_INSTANCE;

typedef struct _CMOCK_osKernelResume_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t Expected_sleep_ticks;

} CMOCK_osKernelResume_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetTickCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelGetTickCount_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetTickFreq_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelGetTickFreq_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE;

typedef struct _CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE;

typedef struct _CMOCK_osThreadNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadId_t ReturnVal;
    osThreadFunc_t Expected_func;
    void* Expected_argument;
    const osThreadAttr_t* Expected_attr;

} CMOCK_osThreadNew_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadGetName_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetId_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadId_t ReturnVal;

} CMOCK_osThreadGetId_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetState_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadState_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadGetState_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetStackSize_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadGetStackSize_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetStackSpace_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadGetStackSpace_CALL_INSTANCE;

typedef struct _CMOCK_osThreadSetPriority_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;
    osPriority_t Expected_priority;

} CMOCK_osThreadSetPriority_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetPriority_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osPriority_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadGetPriority_CALL_INSTANCE;

typedef struct _CMOCK_osThreadYield_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;

} CMOCK_osThreadYield_CALL_INSTANCE;

typedef struct _CMOCK_osThreadSuspend_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadSuspend_CALL_INSTANCE;

typedef struct _CMOCK_osThreadResume_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadResume_CALL_INSTANCE;

typedef struct _CMOCK_osThreadDetach_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadDetach_CALL_INSTANCE;

typedef struct _CMOCK_osThreadJoin_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadJoin_CALL_INSTANCE;

typedef struct _CMOCK_osThreadExit_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;

} CMOCK_osThreadExit_CALL_INSTANCE;

typedef struct _CMOCK_osThreadTerminate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osThreadId_t Expected_thread_id;

} CMOCK_osThreadTerminate_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osThreadGetCount_CALL_INSTANCE;

typedef struct _CMOCK_osThreadEnumerate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osThreadId_t* Expected_thread_array;
    uint32_t Expected_array_items;

} CMOCK_osThreadEnumerate_CALL_INSTANCE;

typedef struct _CMOCK_osThreadFlagsSet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osThreadId_t Expected_thread_id;
    uint32_t Expected_flags;

} CMOCK_osThreadFlagsSet_CALL_INSTANCE;

typedef struct _CMOCK_osThreadFlagsClear_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    uint32_t Expected_flags;

} CMOCK_osThreadFlagsClear_CALL_INSTANCE;

typedef struct _CMOCK_osThreadFlagsGet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osThreadFlagsGet_CALL_INSTANCE;

typedef struct _CMOCK_osThreadFlagsWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    uint32_t Expected_flags;
    uint32_t Expected_options;
    uint32_t Expected_timeout;

} CMOCK_osThreadFlagsWait_CALL_INSTANCE;

typedef struct _CMOCK_osDelay_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    uint32_t Expected_ticks;

} CMOCK_osDelay_CALL_INSTANCE;

typedef struct _CMOCK_osDelayUntil_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    uint32_t Expected_ticks;

} CMOCK_osDelayUntil_CALL_INSTANCE;

typedef struct _CMOCK_osTimerNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osTimerId_t ReturnVal;
    osTimerFunc_t Expected_func;
    osTimerType_t Expected_type;
    void* Expected_argument;
    const osTimerAttr_t* Expected_attr;

} CMOCK_osTimerNew_CALL_INSTANCE;

typedef struct _CMOCK_osTimerGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osTimerId_t Expected_timer_id;

} CMOCK_osTimerGetName_CALL_INSTANCE;

typedef struct _CMOCK_osTimerStart_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osTimerId_t Expected_timer_id;
    uint32_t Expected_ticks;

} CMOCK_osTimerStart_CALL_INSTANCE;

typedef struct _CMOCK_osTimerStop_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osTimerId_t Expected_timer_id;

} CMOCK_osTimerStop_CALL_INSTANCE;

typedef struct _CMOCK_osTimerIsRunning_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osTimerId_t Expected_timer_id;

} CMOCK_osTimerIsRunning_CALL_INSTANCE;

typedef struct _CMOCK_osTimerDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osTimerId_t Expected_timer_id;

} CMOCK_osTimerDelete_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEventFlagsId_t ReturnVal;
    const osEventFlagsAttr_t* Expected_attr;

} CMOCK_osEventFlagsNew_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osEventFlagsId_t Expected_ef_id;

} CMOCK_osEventFlagsGetName_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsSet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osEventFlagsId_t Expected_ef_id;
    uint32_t Expected_flags;

} CMOCK_osEventFlagsSet_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsClear_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osEventFlagsId_t Expected_ef_id;
    uint32_t Expected_flags;

} CMOCK_osEventFlagsClear_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsGet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osEventFlagsId_t Expected_ef_id;

} CMOCK_osEventFlagsGet_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osEventFlagsId_t Expected_ef_id;
    uint32_t Expected_flags;
    uint32_t Expected_options;
    uint32_t Expected_timeout;

} CMOCK_osEventFlagsWait_CALL_INSTANCE;

typedef struct _CMOCK_osEventFlagsDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osEventFlagsId_t Expected_ef_id;

} CMOCK_osEventFlagsDelete_CALL_INSTANCE;

typedef struct _CMOCK_osMutexNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMutexId_t ReturnVal;
    const osMutexAttr_t* Expected_attr;

} CMOCK_osMutexNew_CALL_INSTANCE;

typedef struct _CMOCK_osMutexGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osMutexId_t Expected_mutex_id;

} CMOCK_osMutexGetName_CALL_INSTANCE;

typedef struct _CMOCK_osMutexAcquire_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMutexId_t Expected_mutex_id;
    uint32_t Expected_timeout;

} CMOCK_osMutexAcquire_CALL_INSTANCE;

typedef struct _CMOCK_osMutexRelease_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMutexId_t Expected_mutex_id;

} CMOCK_osMutexRelease_CALL_INSTANCE;

typedef struct _CMOCK_osMutexGetOwner_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadId_t ReturnVal;
    osMutexId_t Expected_mutex_id;

} CMOCK_osMutexGetOwner_CALL_INSTANCE;

typedef struct _CMOCK_osMutexDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMutexId_t Expected_mutex_id;

} CMOCK_osMutexDelete_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osSemaphoreId_t ReturnVal;
    uint32_t Expected_max_count;
    uint32_t Expected_initial_count;
    const osSemaphoreAttr_t* Expected_attr;

} CMOCK_osSemaphoreNew_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osSemaphoreId_t Expected_semaphore_id;

} CMOCK_osSemaphoreGetName_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreAcquire_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osSemaphoreId_t Expected_semaphore_id;
    uint32_t Expected_timeout;

} CMOCK_osSemaphoreAcquire_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreRelease_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osSemaphoreId_t Expected_semaphore_id;

} CMOCK_osSemaphoreRelease_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreGetCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osSemaphoreId_t Expected_semaphore_id;

} CMOCK_osSemaphoreGetCount_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osSemaphoreId_t Expected_semaphore_id;

} CMOCK_osSemaphoreDelete_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMemoryPoolId_t ReturnVal;
    uint32_t Expected_block_count;
    uint32_t Expected_block_size;
    const osMemoryPoolAttr_t* Expected_attr;

} CMOCK_osMemoryPoolNew_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolGetName_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolAlloc_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    void* ReturnVal;
    osMemoryPoolId_t Expected_mp_id;
    uint32_t Expected_timeout;

} CMOCK_osMemoryPoolAlloc_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolFree_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;
    void* Expected_block;

} CMOCK_osMemoryPoolFree_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolGetCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolGetCount_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE;

typedef struct _CMOCK_osMemoryPoolDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMemoryPoolId_t Expected_mp_id;

} CMOCK_osMemoryPoolDelete_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueNew_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMessageQueueId_t ReturnVal;
    uint32_t Expected_msg_count;
    uint32_t Expected_msg_size;
    const osMessageQueueAttr_t* Expected_attr;

} CMOCK_osMessageQueueNew_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGetName_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    const char* ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueGetName_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueuePut_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;
    const void* Expected_msg_ptr;
    uint8_t Expected_msg_prio;
    uint32_t Expected_timeout;

} CMOCK_osMessageQueuePut_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;
    void* Expected_msg_ptr;
    uint8_t* Expected_msg_prio;
    uint32_t Expected_timeout;

} CMOCK_osMessageQueueGet_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGetCount_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueGetCount_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueGetSpace_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueGetSpace_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueReset_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueReset_CALL_INSTANCE;

typedef struct _CMOCK_osMessageQueueDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus_t ReturnVal;
    osMessageQueueId_t Expected_mq_id;

} CMOCK_osMessageQueueDelete_CALL_INSTANCE;

static struct Mockcmsis_os2Instance
{
    CMOCK_MEM_INDEX_TYPE osKernelInitialize_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetInfo_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetState_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelStart_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelLock_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelUnlock_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelRestoreLock_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelSuspend_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelResume_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetTickCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetTickFreq_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetSysTimerCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelGetSysTimerFreq_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetId_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetState_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetStackSize_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetStackSpace_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadSetPriority_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetPriority_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadYield_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadSuspend_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadResume_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadDetach_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadJoin_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadExit_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadTerminate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadEnumerate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadFlagsSet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadFlagsClear_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadFlagsGet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadFlagsWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osDelay_CallInstance;
    CMOCK_MEM_INDEX_TYPE osDelayUntil_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerStart_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerStop_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerIsRunning_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsSet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsClear_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsGet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osEventFlagsDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexAcquire_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexRelease_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexGetOwner_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreAcquire_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreRelease_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreGetCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolAlloc_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolFree_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolGetCapacity_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolGetBlockSize_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolGetCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolGetSpace_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMemoryPoolDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueNew_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGetName_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueuePut_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGetCapacity_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGetMsgSize_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGetCount_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueGetSpace_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueReset_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageQueueDelete_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockcmsis_os2_Verify(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_MEM_INDEX_TYPE call_instance;
    call_instance = Mock.osKernelInitialize_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelInitialize);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetInfo_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetInfo);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetState_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetState);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelStart_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelStart);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelLock_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelLock);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelUnlock_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelUnlock);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelRestoreLock_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelRestoreLock);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelSuspend_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelSuspend);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelResume_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelResume);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetTickCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetTickCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetTickFreq_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetTickFreq);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetSysTimerCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetSysTimerCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelGetSysTimerFreq_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelGetSysTimerFreq);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetId_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetId);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetState_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetState);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetStackSize_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetStackSize);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetStackSpace_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetStackSpace);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadSetPriority_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadSetPriority);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetPriority_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetPriority);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadYield_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadYield);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadSuspend_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadSuspend);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadResume_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadResume);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadDetach_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadDetach);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadJoin_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadJoin);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadExit_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadExit);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadTerminate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadTerminate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadEnumerate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadEnumerate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadFlagsSet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadFlagsSet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadFlagsClear_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadFlagsClear);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadFlagsGet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadFlagsGet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadFlagsWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadFlagsWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osDelay_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osDelay);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osDelayUntil_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osDelayUntil);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerStart_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerStart);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerStop_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerStop);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerIsRunning_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerIsRunning);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsSet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsSet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsClear_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsClear);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsGet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsGet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osEventFlagsDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osEventFlagsDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexAcquire_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexAcquire);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexRelease_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexRelease);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexGetOwner_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexGetOwner);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreAcquire_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreAcquire);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreRelease_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreRelease);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreGetCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreGetCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolAlloc_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolAlloc);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolFree_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolFree);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolGetCapacity_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolGetCapacity);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolGetBlockSize_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolGetBlockSize);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolGetCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolGetCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolGetSpace_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolGetSpace);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMemoryPoolDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMemoryPoolDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueNew_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueNew);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGetName_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGetName);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueuePut_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueuePut);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGetCapacity_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGetCapacity);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGetMsgSize_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGetMsgSize);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGetCount_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGetCount);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueGetSpace_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueGetSpace);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueReset_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueReset);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageQueueDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageQueueDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }
}

void Mockcmsis_os2_Init(void)
{
    Mockcmsis_os2_Destroy();
}

void Mockcmsis_os2_Destroy(void)
{
    CMock_Guts_MemFreeAll();
    memset(&Mock, 0, sizeof(Mock));
}

osStatus_t osKernelInitialize(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelInitialize_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelInitialize);
    cmock_call_instance = (CMOCK_osKernelInitialize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelInitialize_CallInstance);
    Mock.osKernelInitialize_CallInstance = CMock_Guts_MemNext(Mock.osKernelInitialize_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelInitialize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelInitialize_CALL_INSTANCE));
    CMOCK_osKernelInitialize_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelInitialize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelInitialize_CallInstance = CMock_Guts_MemChain(Mock.osKernelInitialize_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osKernelGetInfo(osVersion_t* version, char* id_buf, uint32_t id_size)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetInfo_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetInfo);
    cmock_call_instance = (CMOCK_osKernelGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetInfo_CallInstance);
    Mock.osKernelGetInfo_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetInfo_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osKernelGetInfo, CMockString_version);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_version), (void*)(version), sizeof(osVersion_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osKernelGetInfo, CMockString_id_buf);
        UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_id_buf, id_buf, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osKernelGetInfo, CMockString_id_size);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_id_size, id_size, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osKernelGetInfo(CMOCK_osKernelGetInfo_CALL_INSTANCE* cmock_call_instance, osVersion_t* version, char* id_buf, uint32_t id_size)
{
    cmock_call_instance->Expected_version = version;
    cmock_call_instance->Expected_id_buf = id_buf;
    cmock_call_instance->Expected_id_size = id_size;
}

void osKernelGetInfo_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osVersion_t* version, char* id_buf, uint32_t id_size, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetInfo_CALL_INSTANCE));
    CMOCK_osKernelGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetInfo_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetInfo_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osKernelGetInfo(cmock_call_instance, version, id_buf, id_size);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osKernelState_t osKernelGetState(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetState_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetState);
    cmock_call_instance = (CMOCK_osKernelGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetState_CallInstance);
    Mock.osKernelGetState_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetState_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelGetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osKernelState_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetState_CALL_INSTANCE));
    CMOCK_osKernelGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetState_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetState_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osKernelState_t[sizeof(cmock_to_return) == sizeof(osKernelState_t) ? 1 : -1])); /* add osKernelState_t to :treat_as_array if this causes an error */
}

osStatus_t osKernelStart(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelStart_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelStart);
    cmock_call_instance = (CMOCK_osKernelStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelStart_CallInstance);
    Mock.osKernelStart_CallInstance = CMock_Guts_MemNext(Mock.osKernelStart_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelStart_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelStart_CALL_INSTANCE));
    CMOCK_osKernelStart_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelStart_CallInstance = CMock_Guts_MemChain(Mock.osKernelStart_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

int32_t osKernelLock(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelLock_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelLock);
    cmock_call_instance = (CMOCK_osKernelLock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelLock_CallInstance);
    Mock.osKernelLock_CallInstance = CMock_Guts_MemNext(Mock.osKernelLock_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelLock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelLock_CALL_INSTANCE));
    CMOCK_osKernelLock_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelLock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelLock_CallInstance = CMock_Guts_MemChain(Mock.osKernelLock_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

int32_t osKernelUnlock(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelUnlock_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelUnlock);
    cmock_call_instance = (CMOCK_osKernelUnlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelUnlock_CallInstance);
    Mock.osKernelUnlock_CallInstance = CMock_Guts_MemNext(Mock.osKernelUnlock_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelUnlock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelUnlock_CALL_INSTANCE));
    CMOCK_osKernelUnlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelUnlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelUnlock_CallInstance = CMock_Guts_MemChain(Mock.osKernelUnlock_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

int32_t osKernelRestoreLock(int32_t lock)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelRestoreLock_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelRestoreLock);
    cmock_call_instance = (CMOCK_osKernelRestoreLock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelRestoreLock_CallInstance);
    Mock.osKernelRestoreLock_CallInstance = CMock_Guts_MemNext(Mock.osKernelRestoreLock_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osKernelRestoreLock, CMockString_lock);
        UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_lock, lock, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osKernelRestoreLock(CMOCK_osKernelRestoreLock_CALL_INSTANCE* cmock_call_instance, int32_t lock)
{
    cmock_call_instance->Expected_lock = lock;
}

void osKernelRestoreLock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t lock, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelRestoreLock_CALL_INSTANCE));
    CMOCK_osKernelRestoreLock_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelRestoreLock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelRestoreLock_CallInstance = CMock_Guts_MemChain(Mock.osKernelRestoreLock_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osKernelRestoreLock(cmock_call_instance, lock);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osKernelSuspend(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelSuspend_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelSuspend);
    cmock_call_instance = (CMOCK_osKernelSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelSuspend_CallInstance);
    Mock.osKernelSuspend_CallInstance = CMock_Guts_MemNext(Mock.osKernelSuspend_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelSuspend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelSuspend_CALL_INSTANCE));
    CMOCK_osKernelSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelSuspend_CallInstance = CMock_Guts_MemChain(Mock.osKernelSuspend_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

void osKernelResume(uint32_t sleep_ticks)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelResume_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelResume);
    cmock_call_instance = (CMOCK_osKernelResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelResume_CallInstance);
    Mock.osKernelResume_CallInstance = CMock_Guts_MemNext(Mock.osKernelResume_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osKernelResume, CMockString_sleep_ticks);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_sleep_ticks, sleep_ticks, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
}

void CMockExpectParameters_osKernelResume(CMOCK_osKernelResume_CALL_INSTANCE* cmock_call_instance, uint32_t sleep_ticks)
{
    cmock_call_instance->Expected_sleep_ticks = sleep_ticks;
}

void osKernelResume_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t sleep_ticks)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelResume_CALL_INSTANCE));
    CMOCK_osKernelResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelResume_CallInstance = CMock_Guts_MemChain(Mock.osKernelResume_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osKernelResume(cmock_call_instance, sleep_ticks);
}

uint32_t osKernelGetTickCount(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetTickCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetTickCount);
    cmock_call_instance = (CMOCK_osKernelGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetTickCount_CallInstance);
    Mock.osKernelGetTickCount_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetTickCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelGetTickCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetTickCount_CALL_INSTANCE));
    CMOCK_osKernelGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetTickCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osKernelGetTickFreq(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetTickFreq_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetTickFreq);
    cmock_call_instance = (CMOCK_osKernelGetTickFreq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetTickFreq_CallInstance);
    Mock.osKernelGetTickFreq_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetTickFreq_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelGetTickFreq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetTickFreq_CALL_INSTANCE));
    CMOCK_osKernelGetTickFreq_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetTickFreq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetTickFreq_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetTickFreq_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osKernelGetSysTimerCount(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetSysTimerCount);
    cmock_call_instance = (CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetSysTimerCount_CallInstance);
    Mock.osKernelGetSysTimerCount_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetSysTimerCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelGetSysTimerCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE));
    CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetSysTimerCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetSysTimerCount_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetSysTimerCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osKernelGetSysTimerFreq(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelGetSysTimerFreq);
    cmock_call_instance = (CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelGetSysTimerFreq_CallInstance);
    Mock.osKernelGetSysTimerFreq_CallInstance = CMock_Guts_MemNext(Mock.osKernelGetSysTimerFreq_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelGetSysTimerFreq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE));
    CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelGetSysTimerFreq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelGetSysTimerFreq_CallInstance = CMock_Guts_MemChain(Mock.osKernelGetSysTimerFreq_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osThreadId_t osThreadNew(osThreadFunc_t func, void* argument, const osThreadAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadNew);
    cmock_call_instance = (CMOCK_osThreadNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadNew_CallInstance);
    Mock.osThreadNew_CallInstance = CMock_Guts_MemNext(Mock.osThreadNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadNew, CMockString_func);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_func), (void*)(&func), sizeof(osThreadFunc_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadNew, CMockString_argument);

        if (cmock_call_instance->Expected_argument == NULL)
        {
            UNITY_TEST_ASSERT_NULL(argument, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_argument, argument, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osThreadAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadNew(CMOCK_osThreadNew_CALL_INSTANCE* cmock_call_instance, osThreadFunc_t func, void* argument, const osThreadAttr_t* attr)
{
    memcpy((void*)(&cmock_call_instance->Expected_func), (void*)(&func),
           sizeof(osThreadFunc_t[sizeof(func) == sizeof(osThreadFunc_t) ? 1 : -1])); /* add osThreadFunc_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_argument = argument;
    cmock_call_instance->Expected_attr = attr;
}

void osThreadNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadFunc_t func, void* argument, const osThreadAttr_t* attr, osThreadId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadNew_CALL_INSTANCE));
    CMOCK_osThreadNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadNew_CallInstance = CMock_Guts_MemChain(Mock.osThreadNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadNew(cmock_call_instance, func, argument, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadId_t[sizeof(cmock_to_return) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

const char* osThreadGetName(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetName);
    cmock_call_instance = (CMOCK_osThreadGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetName_CallInstance);
    Mock.osThreadGetName_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetName, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetName(CMOCK_osThreadGetName_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetName_CALL_INSTANCE));
    CMOCK_osThreadGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetName_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetName(cmock_call_instance, thread_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osThreadId_t osThreadGetId(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetId_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetId);
    cmock_call_instance = (CMOCK_osThreadGetId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetId_CallInstance);
    Mock.osThreadGetId_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetId_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadGetId_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetId_CALL_INSTANCE));
    CMOCK_osThreadGetId_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetId_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetId_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadId_t[sizeof(cmock_to_return) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

osThreadState_t osThreadGetState(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetState);
    cmock_call_instance = (CMOCK_osThreadGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetState_CallInstance);
    Mock.osThreadGetState_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetState_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetState, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetState(CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadGetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osThreadState_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetState_CALL_INSTANCE));
    CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetState_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetState_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetState(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadState_t[sizeof(cmock_to_return) == sizeof(osThreadState_t) ? 1 : -1])); /* add osThreadState_t to :treat_as_array if this causes an error */
}

uint32_t osThreadGetStackSize(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetStackSize_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetStackSize);
    cmock_call_instance = (CMOCK_osThreadGetStackSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetStackSize_CallInstance);
    Mock.osThreadGetStackSize_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetStackSize_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetStackSize, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetStackSize(CMOCK_osThreadGetStackSize_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadGetStackSize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetStackSize_CALL_INSTANCE));
    CMOCK_osThreadGetStackSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetStackSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetStackSize_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetStackSize_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetStackSize(cmock_call_instance, thread_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadGetStackSpace(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetStackSpace_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetStackSpace);
    cmock_call_instance = (CMOCK_osThreadGetStackSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetStackSpace_CallInstance);
    Mock.osThreadGetStackSpace_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetStackSpace_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetStackSpace, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetStackSpace(CMOCK_osThreadGetStackSpace_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadGetStackSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetStackSpace_CALL_INSTANCE));
    CMOCK_osThreadGetStackSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetStackSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetStackSpace_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetStackSpace_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetStackSpace(cmock_call_instance, thread_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osThreadSetPriority(osThreadId_t thread_id, osPriority_t priority)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadSetPriority);
    cmock_call_instance = (CMOCK_osThreadSetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadSetPriority_CallInstance);
    Mock.osThreadSetPriority_CallInstance = CMock_Guts_MemNext(Mock.osThreadSetPriority_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadSetPriority, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadSetPriority, CMockString_priority);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_priority), (void*)(&priority), sizeof(osPriority_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadSetPriority(CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id, osPriority_t priority)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
    memcpy((void*)(&cmock_call_instance->Expected_priority), (void*)(&priority),
           sizeof(osPriority_t[sizeof(priority) == sizeof(osPriority_t) ? 1 : -1])); /* add osPriority_t to :treat_as_array if this causes an error */
}

void osThreadSetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osPriority_t priority, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadSetPriority_CALL_INSTANCE));
    CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadSetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadSetPriority_CallInstance = CMock_Guts_MemChain(Mock.osThreadSetPriority_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadSetPriority(cmock_call_instance, thread_id, priority);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osPriority_t osThreadGetPriority(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetPriority);
    cmock_call_instance = (CMOCK_osThreadGetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetPriority_CallInstance);
    Mock.osThreadGetPriority_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetPriority_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetPriority, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetPriority(CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadGetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osPriority_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetPriority_CALL_INSTANCE));
    CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetPriority_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetPriority_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetPriority(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osPriority_t[sizeof(cmock_to_return) == sizeof(osPriority_t) ? 1 : -1])); /* add osPriority_t to :treat_as_array if this causes an error */
}

osStatus_t osThreadYield(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadYield_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadYield);
    cmock_call_instance = (CMOCK_osThreadYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadYield_CallInstance);
    Mock.osThreadYield_CallInstance = CMock_Guts_MemNext(Mock.osThreadYield_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadYield_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadYield_CALL_INSTANCE));
    CMOCK_osThreadYield_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadYield_CallInstance = CMock_Guts_MemChain(Mock.osThreadYield_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osThreadSuspend(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadSuspend);
    cmock_call_instance = (CMOCK_osThreadSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadSuspend_CallInstance);
    Mock.osThreadSuspend_CallInstance = CMock_Guts_MemNext(Mock.osThreadSuspend_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadSuspend, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadSuspend(CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadSuspend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadSuspend_CALL_INSTANCE));
    CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadSuspend_CallInstance = CMock_Guts_MemChain(Mock.osThreadSuspend_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadSuspend(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osThreadResume(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadResume);
    cmock_call_instance = (CMOCK_osThreadResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadResume_CallInstance);
    Mock.osThreadResume_CallInstance = CMock_Guts_MemNext(Mock.osThreadResume_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadResume, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadResume(CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadResume_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadResume_CALL_INSTANCE));
    CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadResume_CallInstance = CMock_Guts_MemChain(Mock.osThreadResume_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadResume(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osThreadDetach(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadDetach_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadDetach);
    cmock_call_instance = (CMOCK_osThreadDetach_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadDetach_CallInstance);
    Mock.osThreadDetach_CallInstance = CMock_Guts_MemNext(Mock.osThreadDetach_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadDetach, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadDetach(CMOCK_osThreadDetach_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadDetach_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadDetach_CALL_INSTANCE));
    CMOCK_osThreadDetach_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadDetach_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadDetach_CallInstance = CMock_Guts_MemChain(Mock.osThreadDetach_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadDetach(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osThreadJoin(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadJoin_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadJoin);
    cmock_call_instance = (CMOCK_osThreadJoin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadJoin_CallInstance);
    Mock.osThreadJoin_CallInstance = CMock_Guts_MemNext(Mock.osThreadJoin_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadJoin, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadJoin(CMOCK_osThreadJoin_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadJoin_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadJoin_CALL_INSTANCE));
    CMOCK_osThreadJoin_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadJoin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadJoin_CallInstance = CMock_Guts_MemChain(Mock.osThreadJoin_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadJoin(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

__NO_RETURN void osThreadExit(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadExit_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadExit);
    cmock_call_instance = (CMOCK_osThreadExit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadExit_CallInstance);
    Mock.osThreadExit_CallInstance = CMock_Guts_MemNext(Mock.osThreadExit_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
}

void osThreadExit_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadExit_CALL_INSTANCE));
    CMOCK_osThreadExit_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadExit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadExit_CallInstance = CMock_Guts_MemChain(Mock.osThreadExit_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
}

osStatus_t osThreadTerminate(osThreadId_t thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadTerminate);
    cmock_call_instance = (CMOCK_osThreadTerminate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadTerminate_CallInstance);
    Mock.osThreadTerminate_CallInstance = CMock_Guts_MemNext(Mock.osThreadTerminate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadTerminate, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadTerminate(CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

void osThreadTerminate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadTerminate_CALL_INSTANCE));
    CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadTerminate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadTerminate_CallInstance = CMock_Guts_MemChain(Mock.osThreadTerminate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadTerminate(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

uint32_t osThreadGetCount(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetCount);
    cmock_call_instance = (CMOCK_osThreadGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetCount_CallInstance);
    Mock.osThreadGetCount_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadGetCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetCount_CALL_INSTANCE));
    CMOCK_osThreadGetCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetCount_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadEnumerate(osThreadId_t* thread_array, uint32_t array_items)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadEnumerate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadEnumerate);
    cmock_call_instance = (CMOCK_osThreadEnumerate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadEnumerate_CallInstance);
    Mock.osThreadEnumerate_CallInstance = CMock_Guts_MemNext(Mock.osThreadEnumerate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadEnumerate, CMockString_thread_array);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_thread_array), (void*)(thread_array), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadEnumerate, CMockString_array_items);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_array_items, array_items, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadEnumerate(CMOCK_osThreadEnumerate_CALL_INSTANCE* cmock_call_instance, osThreadId_t* thread_array, uint32_t array_items)
{
    cmock_call_instance->Expected_thread_array = thread_array;
    cmock_call_instance->Expected_array_items = array_items;
}

void osThreadEnumerate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t* thread_array, uint32_t array_items, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadEnumerate_CALL_INSTANCE));
    CMOCK_osThreadEnumerate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadEnumerate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadEnumerate_CallInstance = CMock_Guts_MemChain(Mock.osThreadEnumerate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadEnumerate(cmock_call_instance, thread_array, array_items);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadFlagsSet(osThreadId_t thread_id, uint32_t flags)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadFlagsSet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadFlagsSet);
    cmock_call_instance = (CMOCK_osThreadFlagsSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadFlagsSet_CallInstance);
    Mock.osThreadFlagsSet_CallInstance = CMock_Guts_MemNext(Mock.osThreadFlagsSet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsSet, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsSet, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadFlagsSet(CMOCK_osThreadFlagsSet_CALL_INSTANCE* cmock_call_instance, osThreadId_t thread_id, uint32_t flags)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId_t[sizeof(thread_id) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_flags = flags;
}

void osThreadFlagsSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId_t thread_id, uint32_t flags, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadFlagsSet_CALL_INSTANCE));
    CMOCK_osThreadFlagsSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadFlagsSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadFlagsSet_CallInstance = CMock_Guts_MemChain(Mock.osThreadFlagsSet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadFlagsSet(cmock_call_instance, thread_id, flags);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadFlagsClear(uint32_t flags)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadFlagsClear_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadFlagsClear);
    cmock_call_instance = (CMOCK_osThreadFlagsClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadFlagsClear_CallInstance);
    Mock.osThreadFlagsClear_CallInstance = CMock_Guts_MemNext(Mock.osThreadFlagsClear_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsClear, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadFlagsClear(CMOCK_osThreadFlagsClear_CALL_INSTANCE* cmock_call_instance, uint32_t flags)
{
    cmock_call_instance->Expected_flags = flags;
}

void osThreadFlagsClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t flags, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadFlagsClear_CALL_INSTANCE));
    CMOCK_osThreadFlagsClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadFlagsClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadFlagsClear_CallInstance = CMock_Guts_MemChain(Mock.osThreadFlagsClear_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadFlagsClear(cmock_call_instance, flags);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadFlagsGet(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadFlagsGet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadFlagsGet);
    cmock_call_instance = (CMOCK_osThreadFlagsGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadFlagsGet_CallInstance);
    Mock.osThreadFlagsGet_CallInstance = CMock_Guts_MemNext(Mock.osThreadFlagsGet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadFlagsGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadFlagsGet_CALL_INSTANCE));
    CMOCK_osThreadFlagsGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadFlagsGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadFlagsGet_CallInstance = CMock_Guts_MemChain(Mock.osThreadFlagsGet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osThreadFlagsWait(uint32_t flags, uint32_t options, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadFlagsWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadFlagsWait);
    cmock_call_instance = (CMOCK_osThreadFlagsWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadFlagsWait_CallInstance);
    Mock.osThreadFlagsWait_CallInstance = CMock_Guts_MemNext(Mock.osThreadFlagsWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsWait, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsWait, CMockString_options);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_options, options, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadFlagsWait, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadFlagsWait(CMOCK_osThreadFlagsWait_CALL_INSTANCE* cmock_call_instance, uint32_t flags, uint32_t options, uint32_t timeout)
{
    cmock_call_instance->Expected_flags = flags;
    cmock_call_instance->Expected_options = options;
    cmock_call_instance->Expected_timeout = timeout;
}

void osThreadFlagsWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t flags, uint32_t options, uint32_t timeout, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadFlagsWait_CALL_INSTANCE));
    CMOCK_osThreadFlagsWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadFlagsWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadFlagsWait_CallInstance = CMock_Guts_MemChain(Mock.osThreadFlagsWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadFlagsWait(cmock_call_instance, flags, options, timeout);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osDelay(uint32_t ticks)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osDelay);
    cmock_call_instance = (CMOCK_osDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osDelay_CallInstance);
    Mock.osDelay_CallInstance = CMock_Guts_MemNext(Mock.osDelay_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osDelay, CMockString_ticks);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ticks, ticks, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osDelay(CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance, uint32_t ticks)
{
    cmock_call_instance->Expected_ticks = ticks;
}

void osDelay_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ticks, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osDelay_CALL_INSTANCE));
    CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_osDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osDelay_CallInstance = CMock_Guts_MemChain(Mock.osDelay_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osDelay(cmock_call_instance, ticks);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osDelayUntil(uint32_t ticks)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osDelayUntil);
    cmock_call_instance = (CMOCK_osDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osDelayUntil_CallInstance);
    Mock.osDelayUntil_CallInstance = CMock_Guts_MemNext(Mock.osDelayUntil_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osDelayUntil, CMockString_ticks);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ticks, ticks, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osDelayUntil(CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance, uint32_t ticks)
{
    cmock_call_instance->Expected_ticks = ticks;
}

void osDelayUntil_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ticks, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osDelayUntil_CALL_INSTANCE));
    CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_osDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.osDelayUntil_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osDelayUntil(cmock_call_instance, ticks);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osTimerId_t osTimerNew(osTimerFunc_t func, osTimerType_t type, void* argument, const osTimerAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerNew);
    cmock_call_instance = (CMOCK_osTimerNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerNew_CallInstance);
    Mock.osTimerNew_CallInstance = CMock_Guts_MemNext(Mock.osTimerNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerNew, CMockString_func);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_func), (void*)(&func), sizeof(osTimerFunc_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerNew, CMockString_type);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_type), (void*)(&type), sizeof(osTimerType_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerNew, CMockString_argument);

        if (cmock_call_instance->Expected_argument == NULL)
        {
            UNITY_TEST_ASSERT_NULL(argument, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_argument, argument, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osTimerAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerNew(CMOCK_osTimerNew_CALL_INSTANCE* cmock_call_instance, osTimerFunc_t func, osTimerType_t type, void* argument, const osTimerAttr_t* attr)
{
    memcpy((void*)(&cmock_call_instance->Expected_func), (void*)(&func),
           sizeof(osTimerFunc_t[sizeof(func) == sizeof(osTimerFunc_t) ? 1 : -1])); /* add osTimerFunc_t to :treat_as_array if this causes an error */
    memcpy((void*)(&cmock_call_instance->Expected_type), (void*)(&type),
           sizeof(osTimerType_t[sizeof(type) == sizeof(osTimerType_t) ? 1 : -1])); /* add osTimerType_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_argument = argument;
    cmock_call_instance->Expected_attr = attr;
}

void osTimerNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerFunc_t func, osTimerType_t type, void* argument, const osTimerAttr_t* attr, osTimerId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerNew_CALL_INSTANCE));
    CMOCK_osTimerNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerNew_CallInstance = CMock_Guts_MemChain(Mock.osTimerNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerNew(cmock_call_instance, func, type, argument, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osTimerId_t[sizeof(cmock_to_return) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
}

const char* osTimerGetName(osTimerId_t timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerGetName);
    cmock_call_instance = (CMOCK_osTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerGetName_CallInstance);
    Mock.osTimerGetName_CallInstance = CMock_Guts_MemNext(Mock.osTimerGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerGetName, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerGetName(CMOCK_osTimerGetName_CALL_INSTANCE* cmock_call_instance, osTimerId_t timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId_t[sizeof(timer_id) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
}

void osTimerGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId_t timer_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerGetName_CALL_INSTANCE));
    CMOCK_osTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.osTimerGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerGetName(cmock_call_instance, timer_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osTimerStart(osTimerId_t timer_id, uint32_t ticks)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerStart);
    cmock_call_instance = (CMOCK_osTimerStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerStart_CallInstance);
    Mock.osTimerStart_CallInstance = CMock_Guts_MemNext(Mock.osTimerStart_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerStart, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerStart, CMockString_ticks);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ticks, ticks, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerStart(CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance, osTimerId_t timer_id, uint32_t ticks)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId_t[sizeof(timer_id) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_ticks = ticks;
}

void osTimerStart_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId_t timer_id, uint32_t ticks, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerStart_CALL_INSTANCE));
    CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerStart_CallInstance = CMock_Guts_MemChain(Mock.osTimerStart_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerStart(cmock_call_instance, timer_id, ticks);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osTimerStop(osTimerId_t timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerStop);
    cmock_call_instance = (CMOCK_osTimerStop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerStop_CallInstance);
    Mock.osTimerStop_CallInstance = CMock_Guts_MemNext(Mock.osTimerStop_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerStop, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerStop(CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance, osTimerId_t timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId_t[sizeof(timer_id) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
}

void osTimerStop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId_t timer_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerStop_CALL_INSTANCE));
    CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerStop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerStop_CallInstance = CMock_Guts_MemChain(Mock.osTimerStop_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerStop(cmock_call_instance, timer_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

uint32_t osTimerIsRunning(osTimerId_t timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerIsRunning_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerIsRunning);
    cmock_call_instance = (CMOCK_osTimerIsRunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerIsRunning_CallInstance);
    Mock.osTimerIsRunning_CallInstance = CMock_Guts_MemNext(Mock.osTimerIsRunning_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerIsRunning, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerIsRunning(CMOCK_osTimerIsRunning_CALL_INSTANCE* cmock_call_instance, osTimerId_t timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId_t[sizeof(timer_id) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
}

void osTimerIsRunning_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId_t timer_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerIsRunning_CALL_INSTANCE));
    CMOCK_osTimerIsRunning_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerIsRunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerIsRunning_CallInstance = CMock_Guts_MemChain(Mock.osTimerIsRunning_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerIsRunning(cmock_call_instance, timer_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osTimerDelete(osTimerId_t timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerDelete);
    cmock_call_instance = (CMOCK_osTimerDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerDelete_CallInstance);
    Mock.osTimerDelete_CallInstance = CMock_Guts_MemNext(Mock.osTimerDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerDelete, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerDelete(CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance, osTimerId_t timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId_t[sizeof(timer_id) == sizeof(osTimerId_t) ? 1 : -1])); /* add osTimerId_t to :treat_as_array if this causes an error */
}

void osTimerDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId_t timer_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerDelete_CALL_INSTANCE));
    CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerDelete_CallInstance = CMock_Guts_MemChain(Mock.osTimerDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerDelete(cmock_call_instance, timer_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osEventFlagsId_t osEventFlagsNew(const osEventFlagsAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsNew);
    cmock_call_instance = (CMOCK_osEventFlagsNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsNew_CallInstance);
    Mock.osEventFlagsNew_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osEventFlagsAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsNew(CMOCK_osEventFlagsNew_CALL_INSTANCE* cmock_call_instance, const osEventFlagsAttr_t* attr)
{
    cmock_call_instance->Expected_attr = attr;
}

void osEventFlagsNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osEventFlagsAttr_t* attr, osEventFlagsId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsNew_CALL_INSTANCE));
    CMOCK_osEventFlagsNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsNew_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsNew(cmock_call_instance, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEventFlagsId_t[sizeof(cmock_to_return) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
}

const char* osEventFlagsGetName(osEventFlagsId_t ef_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsGetName);
    cmock_call_instance = (CMOCK_osEventFlagsGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsGetName_CallInstance);
    Mock.osEventFlagsGetName_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsGetName, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsGetName(CMOCK_osEventFlagsGetName_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
}

void osEventFlagsGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsGetName_CALL_INSTANCE));
    CMOCK_osEventFlagsGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsGetName_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsGetName(cmock_call_instance, ef_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osEventFlagsSet(osEventFlagsId_t ef_id, uint32_t flags)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsSet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsSet);
    cmock_call_instance = (CMOCK_osEventFlagsSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsSet_CallInstance);
    Mock.osEventFlagsSet_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsSet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsSet, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsSet, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsSet(CMOCK_osEventFlagsSet_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id, uint32_t flags)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_flags = flags;
}

void osEventFlagsSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, uint32_t flags, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsSet_CALL_INSTANCE));
    CMOCK_osEventFlagsSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsSet_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsSet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsSet(cmock_call_instance, ef_id, flags);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsClear_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsClear);
    cmock_call_instance = (CMOCK_osEventFlagsClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsClear_CallInstance);
    Mock.osEventFlagsClear_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsClear_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsClear, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsClear, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsClear(CMOCK_osEventFlagsClear_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id, uint32_t flags)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_flags = flags;
}

void osEventFlagsClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, uint32_t flags, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsClear_CALL_INSTANCE));
    CMOCK_osEventFlagsClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsClear_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsClear_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsClear(cmock_call_instance, ef_id, flags);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osEventFlagsGet(osEventFlagsId_t ef_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsGet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsGet);
    cmock_call_instance = (CMOCK_osEventFlagsGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsGet_CallInstance);
    Mock.osEventFlagsGet_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsGet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsGet, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsGet(CMOCK_osEventFlagsGet_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
}

void osEventFlagsGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsGet_CALL_INSTANCE));
    CMOCK_osEventFlagsGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsGet_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsGet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsGet(cmock_call_instance, ef_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osEventFlagsWait(osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsWait);
    cmock_call_instance = (CMOCK_osEventFlagsWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsWait_CallInstance);
    Mock.osEventFlagsWait_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsWait, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsWait, CMockString_flags);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsWait, CMockString_options);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_options, options, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsWait, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsWait(CMOCK_osEventFlagsWait_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_flags = flags;
    cmock_call_instance->Expected_options = options;
    cmock_call_instance->Expected_timeout = timeout;
}

void osEventFlagsWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsWait_CALL_INSTANCE));
    CMOCK_osEventFlagsWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsWait_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsWait(cmock_call_instance, ef_id, flags, options, timeout);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osEventFlagsDelete(osEventFlagsId_t ef_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osEventFlagsDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osEventFlagsDelete);
    cmock_call_instance = (CMOCK_osEventFlagsDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osEventFlagsDelete_CallInstance);
    Mock.osEventFlagsDelete_CallInstance = CMock_Guts_MemNext(Mock.osEventFlagsDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osEventFlagsDelete, CMockString_ef_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id), sizeof(osEventFlagsId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osEventFlagsDelete(CMOCK_osEventFlagsDelete_CALL_INSTANCE* cmock_call_instance, osEventFlagsId_t ef_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_ef_id), (void*)(&ef_id),
           sizeof(osEventFlagsId_t[sizeof(ef_id) == sizeof(osEventFlagsId_t) ? 1 : -1])); /* add osEventFlagsId_t to :treat_as_array if this causes an error */
}

void osEventFlagsDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osEventFlagsId_t ef_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osEventFlagsDelete_CALL_INSTANCE));
    CMOCK_osEventFlagsDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osEventFlagsDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osEventFlagsDelete_CallInstance = CMock_Guts_MemChain(Mock.osEventFlagsDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osEventFlagsDelete(cmock_call_instance, ef_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osMutexId_t osMutexNew(const osMutexAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexNew);
    cmock_call_instance = (CMOCK_osMutexNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexNew_CallInstance);
    Mock.osMutexNew_CallInstance = CMock_Guts_MemNext(Mock.osMutexNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osMutexAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexNew(CMOCK_osMutexNew_CALL_INSTANCE* cmock_call_instance, const osMutexAttr_t* attr)
{
    cmock_call_instance->Expected_attr = attr;
}

void osMutexNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osMutexAttr_t* attr, osMutexId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexNew_CALL_INSTANCE));
    CMOCK_osMutexNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexNew_CallInstance = CMock_Guts_MemChain(Mock.osMutexNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexNew(cmock_call_instance, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMutexId_t[sizeof(cmock_to_return) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
}

const char* osMutexGetName(osMutexId_t mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexGetName);
    cmock_call_instance = (CMOCK_osMutexGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexGetName_CallInstance);
    Mock.osMutexGetName_CallInstance = CMock_Guts_MemNext(Mock.osMutexGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexGetName, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexGetName(CMOCK_osMutexGetName_CALL_INSTANCE* cmock_call_instance, osMutexId_t mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId_t[sizeof(mutex_id) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
}

void osMutexGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId_t mutex_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexGetName_CALL_INSTANCE));
    CMOCK_osMutexGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexGetName_CallInstance = CMock_Guts_MemChain(Mock.osMutexGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexGetName(cmock_call_instance, mutex_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osMutexAcquire(osMutexId_t mutex_id, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexAcquire_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexAcquire);
    cmock_call_instance = (CMOCK_osMutexAcquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexAcquire_CallInstance);
    Mock.osMutexAcquire_CallInstance = CMock_Guts_MemNext(Mock.osMutexAcquire_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexAcquire, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMutexAcquire, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexAcquire(CMOCK_osMutexAcquire_CALL_INSTANCE* cmock_call_instance, osMutexId_t mutex_id, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId_t[sizeof(mutex_id) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_timeout = timeout;
}

void osMutexAcquire_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId_t mutex_id, uint32_t timeout, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexAcquire_CALL_INSTANCE));
    CMOCK_osMutexAcquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexAcquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexAcquire_CallInstance = CMock_Guts_MemChain(Mock.osMutexAcquire_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexAcquire(cmock_call_instance, mutex_id, timeout);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osMutexRelease(osMutexId_t mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexRelease);
    cmock_call_instance = (CMOCK_osMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexRelease_CallInstance);
    Mock.osMutexRelease_CallInstance = CMock_Guts_MemNext(Mock.osMutexRelease_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexRelease, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexRelease(CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance, osMutexId_t mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId_t[sizeof(mutex_id) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
}

void osMutexRelease_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId_t mutex_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexRelease_CALL_INSTANCE));
    CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexRelease_CallInstance = CMock_Guts_MemChain(Mock.osMutexRelease_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexRelease(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osThreadId_t osMutexGetOwner(osMutexId_t mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexGetOwner_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexGetOwner);
    cmock_call_instance = (CMOCK_osMutexGetOwner_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexGetOwner_CallInstance);
    Mock.osMutexGetOwner_CallInstance = CMock_Guts_MemNext(Mock.osMutexGetOwner_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexGetOwner, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexGetOwner(CMOCK_osMutexGetOwner_CALL_INSTANCE* cmock_call_instance, osMutexId_t mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId_t[sizeof(mutex_id) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
}

void osMutexGetOwner_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId_t mutex_id, osThreadId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexGetOwner_CALL_INSTANCE));
    CMOCK_osMutexGetOwner_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexGetOwner_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexGetOwner_CallInstance = CMock_Guts_MemChain(Mock.osMutexGetOwner_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexGetOwner(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadId_t[sizeof(cmock_to_return) == sizeof(osThreadId_t) ? 1 : -1])); /* add osThreadId_t to :treat_as_array if this causes an error */
}

osStatus_t osMutexDelete(osMutexId_t mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexDelete);
    cmock_call_instance = (CMOCK_osMutexDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexDelete_CallInstance);
    Mock.osMutexDelete_CallInstance = CMock_Guts_MemNext(Mock.osMutexDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexDelete, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexDelete(CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance, osMutexId_t mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId_t[sizeof(mutex_id) == sizeof(osMutexId_t) ? 1 : -1])); /* add osMutexId_t to :treat_as_array if this causes an error */
}

void osMutexDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId_t mutex_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexDelete_CALL_INSTANCE));
    CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexDelete_CallInstance = CMock_Guts_MemChain(Mock.osMutexDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexDelete(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osSemaphoreId_t osSemaphoreNew(uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreNew);
    cmock_call_instance = (CMOCK_osSemaphoreNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreNew_CallInstance);
    Mock.osSemaphoreNew_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreNew, CMockString_max_count);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_max_count, max_count, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreNew, CMockString_initial_count);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_initial_count, initial_count, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osSemaphoreAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreNew(CMOCK_osSemaphoreNew_CALL_INSTANCE* cmock_call_instance, uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t* attr)
{
    cmock_call_instance->Expected_max_count = max_count;
    cmock_call_instance->Expected_initial_count = initial_count;
    cmock_call_instance->Expected_attr = attr;
}

void osSemaphoreNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t* attr, osSemaphoreId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreNew_CALL_INSTANCE));
    CMOCK_osSemaphoreNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreNew_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreNew(cmock_call_instance, max_count, initial_count, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osSemaphoreId_t[sizeof(cmock_to_return) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
}

const char* osSemaphoreGetName(osSemaphoreId_t semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreGetName);
    cmock_call_instance = (CMOCK_osSemaphoreGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreGetName_CallInstance);
    Mock.osSemaphoreGetName_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreGetName, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreGetName(CMOCK_osSemaphoreGetName_CALL_INSTANCE* cmock_call_instance, osSemaphoreId_t semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId_t[sizeof(semaphore_id) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
}

void osSemaphoreGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId_t semaphore_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreGetName_CALL_INSTANCE));
    CMOCK_osSemaphoreGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreGetName_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreGetName(cmock_call_instance, semaphore_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osSemaphoreAcquire(osSemaphoreId_t semaphore_id, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreAcquire_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreAcquire);
    cmock_call_instance = (CMOCK_osSemaphoreAcquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreAcquire_CallInstance);
    Mock.osSemaphoreAcquire_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreAcquire_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreAcquire, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreAcquire, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreAcquire(CMOCK_osSemaphoreAcquire_CALL_INSTANCE* cmock_call_instance, osSemaphoreId_t semaphore_id, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId_t[sizeof(semaphore_id) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_timeout = timeout;
}

void osSemaphoreAcquire_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId_t semaphore_id, uint32_t timeout, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreAcquire_CALL_INSTANCE));
    CMOCK_osSemaphoreAcquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreAcquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreAcquire_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreAcquire_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreAcquire(cmock_call_instance, semaphore_id, timeout);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osSemaphoreRelease(osSemaphoreId_t semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreRelease);
    cmock_call_instance = (CMOCK_osSemaphoreRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreRelease_CallInstance);
    Mock.osSemaphoreRelease_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreRelease_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreRelease, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreRelease(CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance, osSemaphoreId_t semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId_t[sizeof(semaphore_id) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
}

void osSemaphoreRelease_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId_t semaphore_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreRelease_CALL_INSTANCE));
    CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreRelease_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreRelease_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreRelease(cmock_call_instance, semaphore_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

uint32_t osSemaphoreGetCount(osSemaphoreId_t semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreGetCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreGetCount);
    cmock_call_instance = (CMOCK_osSemaphoreGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreGetCount_CallInstance);
    Mock.osSemaphoreGetCount_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreGetCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreGetCount, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreGetCount(CMOCK_osSemaphoreGetCount_CALL_INSTANCE* cmock_call_instance, osSemaphoreId_t semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId_t[sizeof(semaphore_id) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
}

void osSemaphoreGetCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId_t semaphore_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreGetCount_CALL_INSTANCE));
    CMOCK_osSemaphoreGetCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreGetCount_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreGetCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreGetCount(cmock_call_instance, semaphore_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osSemaphoreDelete(osSemaphoreId_t semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreDelete);
    cmock_call_instance = (CMOCK_osSemaphoreDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreDelete_CallInstance);
    Mock.osSemaphoreDelete_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreDelete, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreDelete(CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance, osSemaphoreId_t semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId_t[sizeof(semaphore_id) == sizeof(osSemaphoreId_t) ? 1 : -1])); /* add osSemaphoreId_t to :treat_as_array if this causes an error */
}

void osSemaphoreDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId_t semaphore_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreDelete_CALL_INSTANCE));
    CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreDelete_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreDelete(cmock_call_instance, semaphore_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osMemoryPoolId_t osMemoryPoolNew(uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolNew);
    cmock_call_instance = (CMOCK_osMemoryPoolNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolNew_CallInstance);
    Mock.osMemoryPoolNew_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolNew, CMockString_block_count);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_count, block_count, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolNew, CMockString_block_size);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_size, block_size, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osMemoryPoolAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolNew(CMOCK_osMemoryPoolNew_CALL_INSTANCE* cmock_call_instance, uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t* attr)
{
    cmock_call_instance->Expected_block_count = block_count;
    cmock_call_instance->Expected_block_size = block_size;
    cmock_call_instance->Expected_attr = attr;
}

void osMemoryPoolNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t* attr, osMemoryPoolId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolNew_CALL_INSTANCE));
    CMOCK_osMemoryPoolNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolNew_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolNew(cmock_call_instance, block_count, block_size, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMemoryPoolId_t[sizeof(cmock_to_return) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

const char* osMemoryPoolGetName(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolGetName);
    cmock_call_instance = (CMOCK_osMemoryPoolGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolGetName_CallInstance);
    Mock.osMemoryPoolGetName_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolGetName, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolGetName(CMOCK_osMemoryPoolGetName_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolGetName_CALL_INSTANCE));
    CMOCK_osMemoryPoolGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolGetName_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolGetName(cmock_call_instance, mp_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

void* osMemoryPoolAlloc(osMemoryPoolId_t mp_id, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolAlloc_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolAlloc);
    cmock_call_instance = (CMOCK_osMemoryPoolAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolAlloc_CallInstance);
    Mock.osMemoryPoolAlloc_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolAlloc_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolAlloc, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolAlloc, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolAlloc(CMOCK_osMemoryPoolAlloc_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_timeout = timeout;
}

void osMemoryPoolAlloc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, uint32_t timeout, void* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolAlloc_CALL_INSTANCE));
    CMOCK_osMemoryPoolAlloc_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolAlloc_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolAlloc_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolAlloc(cmock_call_instance, mp_id, timeout);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id, void* block)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolFree_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolFree);
    cmock_call_instance = (CMOCK_osMemoryPoolFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolFree_CallInstance);
    Mock.osMemoryPoolFree_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolFree_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolFree, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolFree, CMockString_block);

        if (cmock_call_instance->Expected_block == NULL)
        {
            UNITY_TEST_ASSERT_NULL(block, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_block, block, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolFree(CMOCK_osMemoryPoolFree_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id, void* block)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_block = block;
}

void osMemoryPoolFree_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, void* block, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolFree_CALL_INSTANCE));
    CMOCK_osMemoryPoolFree_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolFree_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolFree_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolFree(cmock_call_instance, mp_id, block);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolGetCapacity);
    cmock_call_instance = (CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolGetCapacity_CallInstance);
    Mock.osMemoryPoolGetCapacity_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolGetCapacity_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolGetCapacity, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolGetCapacity(CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolGetCapacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE));
    CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolGetCapacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolGetCapacity_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolGetCapacity_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolGetCapacity(cmock_call_instance, mp_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolGetBlockSize);
    cmock_call_instance = (CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolGetBlockSize_CallInstance);
    Mock.osMemoryPoolGetBlockSize_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolGetBlockSize_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolGetBlockSize, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolGetBlockSize(CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolGetBlockSize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE));
    CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolGetBlockSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolGetBlockSize_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolGetBlockSize_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolGetBlockSize(cmock_call_instance, mp_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolGetCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolGetCount);
    cmock_call_instance = (CMOCK_osMemoryPoolGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolGetCount_CallInstance);
    Mock.osMemoryPoolGetCount_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolGetCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolGetCount, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolGetCount(CMOCK_osMemoryPoolGetCount_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolGetCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolGetCount_CALL_INSTANCE));
    CMOCK_osMemoryPoolGetCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolGetCount_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolGetCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolGetCount(cmock_call_instance, mp_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMemoryPoolGetSpace(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolGetSpace);
    cmock_call_instance = (CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolGetSpace_CallInstance);
    Mock.osMemoryPoolGetSpace_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolGetSpace_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolGetSpace, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolGetSpace(CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolGetSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE));
    CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolGetSpace_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolGetSpace_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolGetSpace(cmock_call_instance, mp_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMemoryPoolDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMemoryPoolDelete);
    cmock_call_instance = (CMOCK_osMemoryPoolDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMemoryPoolDelete_CallInstance);
    Mock.osMemoryPoolDelete_CallInstance = CMock_Guts_MemNext(Mock.osMemoryPoolDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMemoryPoolDelete, CMockString_mp_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id), sizeof(osMemoryPoolId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMemoryPoolDelete(CMOCK_osMemoryPoolDelete_CALL_INSTANCE* cmock_call_instance, osMemoryPoolId_t mp_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mp_id), (void*)(&mp_id),
           sizeof(osMemoryPoolId_t[sizeof(mp_id) == sizeof(osMemoryPoolId_t) ? 1 : -1])); /* add osMemoryPoolId_t to :treat_as_array if this causes an error */
}

void osMemoryPoolDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMemoryPoolId_t mp_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMemoryPoolDelete_CALL_INSTANCE));
    CMOCK_osMemoryPoolDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMemoryPoolDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMemoryPoolDelete_CallInstance = CMock_Guts_MemChain(Mock.osMemoryPoolDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMemoryPoolDelete(cmock_call_instance, mp_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osMessageQueueId_t osMessageQueueNew(uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t* attr)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueNew_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueNew);
    cmock_call_instance = (CMOCK_osMessageQueueNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueNew_CallInstance);
    Mock.osMessageQueueNew_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueNew_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueNew, CMockString_msg_count);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_msg_count, msg_count, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueNew, CMockString_msg_size);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_msg_size, msg_size, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueNew, CMockString_attr);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attr), (void*)(attr), sizeof(const osMessageQueueAttr_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueNew(CMOCK_osMessageQueueNew_CALL_INSTANCE* cmock_call_instance, uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t* attr)
{
    cmock_call_instance->Expected_msg_count = msg_count;
    cmock_call_instance->Expected_msg_size = msg_size;
    cmock_call_instance->Expected_attr = attr;
}

void osMessageQueueNew_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t* attr, osMessageQueueId_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueNew_CALL_INSTANCE));
    CMOCK_osMessageQueueNew_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueNew_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueNew_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueNew_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueNew(cmock_call_instance, msg_count, msg_size, attr);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMessageQueueId_t[sizeof(cmock_to_return) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

const char* osMessageQueueGetName(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGetName_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGetName);
    cmock_call_instance = (CMOCK_osMessageQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGetName_CallInstance);
    Mock.osMessageQueueGetName_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGetName_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGetName, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGetName(CMOCK_osMessageQueueGetName_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, const char* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGetName_CALL_INSTANCE));
    CMOCK_osMessageQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGetName_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGetName_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGetName(cmock_call_instance, mq_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osMessageQueuePut(osMessageQueueId_t mq_id, const void* msg_ptr, uint8_t msg_prio, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueuePut_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueuePut);
    cmock_call_instance = (CMOCK_osMessageQueuePut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueuePut_CallInstance);
    Mock.osMessageQueuePut_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueuePut_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueuePut, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueuePut, CMockString_msg_ptr);

        if (cmock_call_instance->Expected_msg_ptr == NULL)
        {
            UNITY_TEST_ASSERT_NULL(msg_ptr, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_msg_ptr, msg_ptr, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueuePut, CMockString_msg_prio);
        UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_msg_prio, msg_prio, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueuePut, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueuePut(CMOCK_osMessageQueuePut_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id, const void* msg_ptr, uint8_t msg_prio, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_msg_ptr = msg_ptr;
    cmock_call_instance->Expected_msg_prio = msg_prio;
    cmock_call_instance->Expected_timeout = timeout;
}

void osMessageQueuePut_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, const void* msg_ptr, uint8_t msg_prio, uint32_t timeout, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueuePut_CALL_INSTANCE));
    CMOCK_osMessageQueuePut_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueuePut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueuePut_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueuePut_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueuePut(cmock_call_instance, mq_id, msg_ptr, msg_prio, timeout);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osMessageQueueGet(osMessageQueueId_t mq_id, void* msg_ptr, uint8_t* msg_prio, uint32_t timeout)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGet);
    cmock_call_instance = (CMOCK_osMessageQueueGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGet_CallInstance);
    Mock.osMessageQueueGet_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGet, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGet, CMockString_msg_ptr);

        if (cmock_call_instance->Expected_msg_ptr == NULL)
        {
            UNITY_TEST_ASSERT_NULL(msg_ptr, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_msg_ptr, msg_ptr, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGet, CMockString_msg_prio);

        if (cmock_call_instance->Expected_msg_prio == NULL)
        {
            UNITY_TEST_ASSERT_NULL(msg_prio, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_msg_prio, msg_prio, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGet, CMockString_timeout);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_timeout, timeout, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGet(CMOCK_osMessageQueueGet_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id, void* msg_ptr, uint8_t* msg_prio, uint32_t timeout)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_msg_ptr = msg_ptr;
    cmock_call_instance->Expected_msg_prio = msg_prio;
    cmock_call_instance->Expected_timeout = timeout;
}

void osMessageQueueGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, void* msg_ptr, uint8_t* msg_prio, uint32_t timeout, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGet_CALL_INSTANCE));
    CMOCK_osMessageQueueGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGet_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGet(cmock_call_instance, mq_id, msg_ptr, msg_prio, timeout);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

uint32_t osMessageQueueGetCapacity(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGetCapacity);
    cmock_call_instance = (CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGetCapacity_CallInstance);
    Mock.osMessageQueueGetCapacity_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGetCapacity_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGetCapacity, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGetCapacity(CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueGetCapacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE));
    CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGetCapacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGetCapacity_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGetCapacity_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGetCapacity(cmock_call_instance, mq_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMessageQueueGetMsgSize(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGetMsgSize);
    cmock_call_instance = (CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGetMsgSize_CallInstance);
    Mock.osMessageQueueGetMsgSize_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGetMsgSize_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGetMsgSize, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGetMsgSize(CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueGetMsgSize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE));
    CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGetMsgSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGetMsgSize_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGetMsgSize_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGetMsgSize(cmock_call_instance, mq_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGetCount_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGetCount);
    cmock_call_instance = (CMOCK_osMessageQueueGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGetCount_CallInstance);
    Mock.osMessageQueueGetCount_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGetCount_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGetCount, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGetCount(CMOCK_osMessageQueueGetCount_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueGetCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGetCount_CALL_INSTANCE));
    CMOCK_osMessageQueueGetCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGetCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGetCount_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGetCount_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGetCount(cmock_call_instance, mq_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osMessageQueueGetSpace(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueGetSpace_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueGetSpace);
    cmock_call_instance = (CMOCK_osMessageQueueGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueGetSpace_CallInstance);
    Mock.osMessageQueueGetSpace_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueGetSpace_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueGetSpace, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueGetSpace(CMOCK_osMessageQueueGetSpace_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueGetSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueGetSpace_CALL_INSTANCE));
    CMOCK_osMessageQueueGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueGetSpace_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueGetSpace_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueGetSpace(cmock_call_instance, mq_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus_t osMessageQueueReset(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueReset_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueReset);
    cmock_call_instance = (CMOCK_osMessageQueueReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueReset_CallInstance);
    Mock.osMessageQueueReset_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueReset_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueReset, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueReset(CMOCK_osMessageQueueReset_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueReset_CALL_INSTANCE));
    CMOCK_osMessageQueueReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueReset_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueReset_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueReset(cmock_call_instance, mq_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

osStatus_t osMessageQueueDelete(osMessageQueueId_t mq_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageQueueDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageQueueDelete);
    cmock_call_instance = (CMOCK_osMessageQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageQueueDelete_CallInstance);
    Mock.osMessageQueueDelete_CallInstance = CMock_Guts_MemNext(Mock.osMessageQueueDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageQueueDelete, CMockString_mq_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id), sizeof(osMessageQueueId_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageQueueDelete(CMOCK_osMessageQueueDelete_CALL_INSTANCE* cmock_call_instance, osMessageQueueId_t mq_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mq_id), (void*)(&mq_id),
           sizeof(osMessageQueueId_t[sizeof(mq_id) == sizeof(osMessageQueueId_t) ? 1 : -1])); /* add osMessageQueueId_t to :treat_as_array if this causes an error */
}

void osMessageQueueDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQueueId_t mq_id, osStatus_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageQueueDelete_CALL_INSTANCE));
    CMOCK_osMessageQueueDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageQueueDelete_CallInstance = CMock_Guts_MemChain(Mock.osMessageQueueDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageQueueDelete(cmock_call_instance, mq_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus_t[sizeof(cmock_to_return) == sizeof(osStatus_t) ? 1 : -1])); /* add osStatus_t to :treat_as_array if this causes an error */
}

