/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockcmsis_os.h"

static const char* CMockString_PreviousWakeTime = "PreviousWakeTime";
static const char* CMockString_argument = "argument";
static const char* CMockString_block = "block";
static const char* CMockString_buffer = "buffer";
static const char* CMockString_count = "count";
static const char* CMockString_info = "info";
static const char* CMockString_mail = "mail";
static const char* CMockString_millisec = "millisec";
static const char* CMockString_mutex_def = "mutex_def";
static const char* CMockString_mutex_id = "mutex_id";
static const char* CMockString_osDelay = "osDelay";
static const char* CMockString_osDelayUntil = "osDelayUntil";
static const char* CMockString_osKernelInitialize = "osKernelInitialize";
static const char* CMockString_osKernelRunning = "osKernelRunning";
static const char* CMockString_osKernelStart = "osKernelStart";
static const char* CMockString_osKernelSysTick = "osKernelSysTick";
static const char* CMockString_osMailAlloc = "osMailAlloc";
static const char* CMockString_osMailCAlloc = "osMailCAlloc";
static const char* CMockString_osMailCreate = "osMailCreate";
static const char* CMockString_osMailFree = "osMailFree";
static const char* CMockString_osMailGet = "osMailGet";
static const char* CMockString_osMailPut = "osMailPut";
static const char* CMockString_osMessageCreate = "osMessageCreate";
static const char* CMockString_osMessageGet = "osMessageGet";
static const char* CMockString_osMessagePeek = "osMessagePeek";
static const char* CMockString_osMessagePut = "osMessagePut";
static const char* CMockString_osMutexCreate = "osMutexCreate";
static const char* CMockString_osMutexDelete = "osMutexDelete";
static const char* CMockString_osMutexRelease = "osMutexRelease";
static const char* CMockString_osMutexWait = "osMutexWait";
static const char* CMockString_osPoolAlloc = "osPoolAlloc";
static const char* CMockString_osPoolCAlloc = "osPoolCAlloc";
static const char* CMockString_osPoolCreate = "osPoolCreate";
static const char* CMockString_osPoolFree = "osPoolFree";
static const char* CMockString_osRecursiveMutexCreate = "osRecursiveMutexCreate";
static const char* CMockString_osRecursiveMutexRelease = "osRecursiveMutexRelease";
static const char* CMockString_osRecursiveMutexWait = "osRecursiveMutexWait";
static const char* CMockString_osSemaphoreCreate = "osSemaphoreCreate";
static const char* CMockString_osSemaphoreDelete = "osSemaphoreDelete";
static const char* CMockString_osSemaphoreRelease = "osSemaphoreRelease";
static const char* CMockString_osSemaphoreWait = "osSemaphoreWait";
static const char* CMockString_osSignalClear = "osSignalClear";
static const char* CMockString_osSignalSet = "osSignalSet";
static const char* CMockString_osSignalWait = "osSignalWait";
static const char* CMockString_osSystickHandler = "osSystickHandler";
static const char* CMockString_osThreadCreate = "osThreadCreate";
static const char* CMockString_osThreadGetId = "osThreadGetId";
static const char* CMockString_osThreadGetPriority = "osThreadGetPriority";
static const char* CMockString_osThreadGetState = "osThreadGetState";
static const char* CMockString_osThreadIsSuspended = "osThreadIsSuspended";
static const char* CMockString_osThreadList = "osThreadList";
static const char* CMockString_osThreadResume = "osThreadResume";
static const char* CMockString_osThreadResumeAll = "osThreadResumeAll";
static const char* CMockString_osThreadSetPriority = "osThreadSetPriority";
static const char* CMockString_osThreadSuspend = "osThreadSuspend";
static const char* CMockString_osThreadSuspendAll = "osThreadSuspendAll";
static const char* CMockString_osThreadTerminate = "osThreadTerminate";
static const char* CMockString_osThreadYield = "osThreadYield";
static const char* CMockString_osTimerCreate = "osTimerCreate";
static const char* CMockString_osTimerDelete = "osTimerDelete";
static const char* CMockString_osTimerStart = "osTimerStart";
static const char* CMockString_osTimerStop = "osTimerStop";
static const char* CMockString_osWait = "osWait";
static const char* CMockString_pool_def = "pool_def";
static const char* CMockString_pool_id = "pool_id";
static const char* CMockString_priority = "priority";
static const char* CMockString_queue_def = "queue_def";
static const char* CMockString_queue_id = "queue_id";
static const char* CMockString_semaphore_def = "semaphore_def";
static const char* CMockString_semaphore_id = "semaphore_id";
static const char* CMockString_signals = "signals";
static const char* CMockString_thread_def = "thread_def";
static const char* CMockString_thread_id = "thread_id";
static const char* CMockString_timer_def = "timer_def";
static const char* CMockString_timer_id = "timer_id";
static const char* CMockString_type = "type";

typedef struct _CMOCK_osKernelInitialize_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;

} CMOCK_osKernelInitialize_CALL_INSTANCE;

typedef struct _CMOCK_osKernelStart_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;

} CMOCK_osKernelStart_CALL_INSTANCE;

typedef struct _CMOCK_osKernelRunning_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;

} CMOCK_osKernelRunning_CALL_INSTANCE;

typedef struct _CMOCK_osKernelSysTick_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    uint32_t ReturnVal;

} CMOCK_osKernelSysTick_CALL_INSTANCE;

typedef struct _CMOCK_osThreadCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadId ReturnVal;
    const osThreadDef_t* Expected_thread_def;
    void* Expected_argument;

} CMOCK_osThreadCreate_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetId_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadId ReturnVal;

} CMOCK_osThreadGetId_CALL_INSTANCE;

typedef struct _CMOCK_osThreadTerminate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadTerminate_CALL_INSTANCE;

typedef struct _CMOCK_osThreadYield_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;

} CMOCK_osThreadYield_CALL_INSTANCE;

typedef struct _CMOCK_osThreadSetPriority_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osThreadId Expected_thread_id;
    osPriority Expected_priority;

} CMOCK_osThreadSetPriority_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetPriority_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osPriority ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadGetPriority_CALL_INSTANCE;

typedef struct _CMOCK_osDelay_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    uint32_t Expected_millisec;

} CMOCK_osDelay_CALL_INSTANCE;

typedef struct _CMOCK_osWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEvent ReturnVal;
    uint32_t Expected_millisec;

} CMOCK_osWait_CALL_INSTANCE;

typedef struct _CMOCK_osTimerCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osTimerId ReturnVal;
    const osTimerDef_t* Expected_timer_def;
    os_timer_type Expected_type;
    void* Expected_argument;

} CMOCK_osTimerCreate_CALL_INSTANCE;

typedef struct _CMOCK_osTimerStart_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osTimerId Expected_timer_id;
    uint32_t Expected_millisec;

} CMOCK_osTimerStart_CALL_INSTANCE;

typedef struct _CMOCK_osTimerStop_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osTimerId Expected_timer_id;

} CMOCK_osTimerStop_CALL_INSTANCE;

typedef struct _CMOCK_osTimerDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osTimerId Expected_timer_id;

} CMOCK_osTimerDelete_CALL_INSTANCE;

typedef struct _CMOCK_osSignalSet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;
    osThreadId Expected_thread_id;
    int32_t Expected_signals;

} CMOCK_osSignalSet_CALL_INSTANCE;

typedef struct _CMOCK_osSignalClear_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;
    osThreadId Expected_thread_id;
    int32_t Expected_signals;

} CMOCK_osSignalClear_CALL_INSTANCE;

typedef struct _CMOCK_osSignalWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEvent ReturnVal;
    int32_t Expected_signals;
    uint32_t Expected_millisec;

} CMOCK_osSignalWait_CALL_INSTANCE;

typedef struct _CMOCK_osMutexCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMutexId ReturnVal;
    const osMutexDef_t* Expected_mutex_def;

} CMOCK_osMutexCreate_CALL_INSTANCE;

typedef struct _CMOCK_osMutexWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMutexId Expected_mutex_id;
    uint32_t Expected_millisec;

} CMOCK_osMutexWait_CALL_INSTANCE;

typedef struct _CMOCK_osMutexRelease_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMutexId Expected_mutex_id;

} CMOCK_osMutexRelease_CALL_INSTANCE;

typedef struct _CMOCK_osMutexDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMutexId Expected_mutex_id;

} CMOCK_osMutexDelete_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osSemaphoreId ReturnVal;
    const osSemaphoreDef_t* Expected_semaphore_def;
    int32_t Expected_count;

} CMOCK_osSemaphoreCreate_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    int32_t ReturnVal;
    osSemaphoreId Expected_semaphore_id;
    uint32_t Expected_millisec;

} CMOCK_osSemaphoreWait_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreRelease_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osSemaphoreId Expected_semaphore_id;

} CMOCK_osSemaphoreRelease_CALL_INSTANCE;

typedef struct _CMOCK_osSemaphoreDelete_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osSemaphoreId Expected_semaphore_id;

} CMOCK_osSemaphoreDelete_CALL_INSTANCE;

typedef struct _CMOCK_osPoolCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osPoolId ReturnVal;
    const osPoolDef_t* Expected_pool_def;

} CMOCK_osPoolCreate_CALL_INSTANCE;

typedef struct _CMOCK_osPoolAlloc_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    void* ReturnVal;
    osPoolId Expected_pool_id;

} CMOCK_osPoolAlloc_CALL_INSTANCE;

typedef struct _CMOCK_osPoolCAlloc_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    void* ReturnVal;
    osPoolId Expected_pool_id;

} CMOCK_osPoolCAlloc_CALL_INSTANCE;

typedef struct _CMOCK_osPoolFree_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osPoolId Expected_pool_id;
    void* Expected_block;

} CMOCK_osPoolFree_CALL_INSTANCE;

typedef struct _CMOCK_osMessageCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMessageQId ReturnVal;
    const osMessageQDef_t* Expected_queue_def;
    osThreadId Expected_thread_id;

} CMOCK_osMessageCreate_CALL_INSTANCE;

typedef struct _CMOCK_osMessagePut_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMessageQId Expected_queue_id;
    uint32_t Expected_info;
    uint32_t Expected_millisec;

} CMOCK_osMessagePut_CALL_INSTANCE;

typedef struct _CMOCK_osMessageGet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEvent ReturnVal;
    osMessageQId Expected_queue_id;
    uint32_t Expected_millisec;

} CMOCK_osMessageGet_CALL_INSTANCE;

typedef struct _CMOCK_osMailCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMailQId ReturnVal;
    const osMailQDef_t* Expected_queue_def;
    osThreadId Expected_thread_id;

} CMOCK_osMailCreate_CALL_INSTANCE;

typedef struct _CMOCK_osMailAlloc_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    void* ReturnVal;
    osMailQId Expected_queue_id;
    uint32_t Expected_millisec;

} CMOCK_osMailAlloc_CALL_INSTANCE;

typedef struct _CMOCK_osMailCAlloc_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    void* ReturnVal;
    osMailQId Expected_queue_id;
    uint32_t Expected_millisec;

} CMOCK_osMailCAlloc_CALL_INSTANCE;

typedef struct _CMOCK_osMailPut_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMailQId Expected_queue_id;
    void* Expected_mail;

} CMOCK_osMailPut_CALL_INSTANCE;

typedef struct _CMOCK_osMailGet_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEvent ReturnVal;
    osMailQId Expected_queue_id;
    uint32_t Expected_millisec;

} CMOCK_osMailGet_CALL_INSTANCE;

typedef struct _CMOCK_osMailFree_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMailQId Expected_queue_id;
    void* Expected_mail;

} CMOCK_osMailFree_CALL_INSTANCE;

typedef struct _CMOCK_osSystickHandler_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;

} CMOCK_osSystickHandler_CALL_INSTANCE;

typedef struct _CMOCK_osThreadGetState_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osThreadState ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadGetState_CALL_INSTANCE;

typedef struct _CMOCK_osThreadIsSuspended_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadIsSuspended_CALL_INSTANCE;

typedef struct _CMOCK_osThreadSuspend_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadSuspend_CALL_INSTANCE;

typedef struct _CMOCK_osThreadResume_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osThreadId Expected_thread_id;

} CMOCK_osThreadResume_CALL_INSTANCE;

typedef struct _CMOCK_osThreadSuspendAll_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;

} CMOCK_osThreadSuspendAll_CALL_INSTANCE;

typedef struct _CMOCK_osThreadResumeAll_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;

} CMOCK_osThreadResumeAll_CALL_INSTANCE;

typedef struct _CMOCK_osDelayUntil_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    uint32_t* Expected_PreviousWakeTime;
    uint32_t Expected_millisec;

} CMOCK_osDelayUntil_CALL_INSTANCE;

typedef struct _CMOCK_osThreadList_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    uint8_t* Expected_buffer;

} CMOCK_osThreadList_CALL_INSTANCE;

typedef struct _CMOCK_osMessagePeek_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osEvent ReturnVal;
    osMessageQId Expected_queue_id;
    uint32_t Expected_millisec;

} CMOCK_osMessagePeek_CALL_INSTANCE;

typedef struct _CMOCK_osRecursiveMutexCreate_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osMutexId ReturnVal;
    const osMutexDef_t* Expected_mutex_def;

} CMOCK_osRecursiveMutexCreate_CALL_INSTANCE;

typedef struct _CMOCK_osRecursiveMutexRelease_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMutexId Expected_mutex_id;

} CMOCK_osRecursiveMutexRelease_CALL_INSTANCE;

typedef struct _CMOCK_osRecursiveMutexWait_CALL_INSTANCE
{
    UNITY_LINE_TYPE LineNumber;
    osStatus ReturnVal;
    osMutexId Expected_mutex_id;
    uint32_t Expected_millisec;

} CMOCK_osRecursiveMutexWait_CALL_INSTANCE;

static struct Mockcmsis_osInstance
{
    CMOCK_MEM_INDEX_TYPE osKernelInitialize_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelStart_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelRunning_CallInstance;
    CMOCK_MEM_INDEX_TYPE osKernelSysTick_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetId_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadTerminate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadYield_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadSetPriority_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetPriority_CallInstance;
    CMOCK_MEM_INDEX_TYPE osDelay_CallInstance;
    CMOCK_MEM_INDEX_TYPE osWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerStart_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerStop_CallInstance;
    CMOCK_MEM_INDEX_TYPE osTimerDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSignalSet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSignalClear_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSignalWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexRelease_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMutexDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreWait_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreRelease_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSemaphoreDelete_CallInstance;
    CMOCK_MEM_INDEX_TYPE osPoolCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osPoolAlloc_CallInstance;
    CMOCK_MEM_INDEX_TYPE osPoolCAlloc_CallInstance;
    CMOCK_MEM_INDEX_TYPE osPoolFree_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessagePut_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessageGet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailAlloc_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailCAlloc_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailPut_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailGet_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMailFree_CallInstance;
    CMOCK_MEM_INDEX_TYPE osSystickHandler_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadGetState_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadIsSuspended_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadSuspend_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadResume_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadSuspendAll_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadResumeAll_CallInstance;
    CMOCK_MEM_INDEX_TYPE osDelayUntil_CallInstance;
    CMOCK_MEM_INDEX_TYPE osThreadList_CallInstance;
    CMOCK_MEM_INDEX_TYPE osMessagePeek_CallInstance;
    CMOCK_MEM_INDEX_TYPE osRecursiveMutexCreate_CallInstance;
    CMOCK_MEM_INDEX_TYPE osRecursiveMutexRelease_CallInstance;
    CMOCK_MEM_INDEX_TYPE osRecursiveMutexWait_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockcmsis_os_Verify(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_MEM_INDEX_TYPE call_instance;
    call_instance = Mock.osKernelInitialize_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelInitialize);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelStart_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelStart);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelRunning_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelRunning);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osKernelSysTick_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osKernelSysTick);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetId_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetId);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadTerminate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadTerminate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadYield_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadYield);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadSetPriority_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadSetPriority);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetPriority_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetPriority);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osDelay_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osDelay);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerStart_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerStart);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerStop_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerStop);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osTimerDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osTimerDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSignalSet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSignalSet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSignalClear_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSignalClear);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSignalWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSignalWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexRelease_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexRelease);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMutexDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMutexDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreRelease_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreRelease);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSemaphoreDelete_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSemaphoreDelete);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osPoolCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osPoolCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osPoolAlloc_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osPoolAlloc);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osPoolCAlloc_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osPoolCAlloc);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osPoolFree_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osPoolFree);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessagePut_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessagePut);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessageGet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessageGet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailAlloc_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailAlloc);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailCAlloc_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailCAlloc);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailPut_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailPut);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailGet_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailGet);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMailFree_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMailFree);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osSystickHandler_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osSystickHandler);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadGetState_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadGetState);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadIsSuspended_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadIsSuspended);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadSuspend_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadSuspend);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadResume_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadResume);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadSuspendAll_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadSuspendAll);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadResumeAll_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadResumeAll);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osDelayUntil_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osDelayUntil);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osThreadList_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osThreadList);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osMessagePeek_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osMessagePeek);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osRecursiveMutexCreate_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osRecursiveMutexCreate);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osRecursiveMutexRelease_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osRecursiveMutexRelease);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }

    call_instance = Mock.osRecursiveMutexWait_CallInstance;

    if (CMOCK_GUTS_NONE != call_instance)
    {
        UNITY_SET_DETAIL(CMockString_osRecursiveMutexWait);
        UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
    }
}

void Mockcmsis_os_Init(void)
{
    Mockcmsis_os_Destroy();
}

void Mockcmsis_os_Destroy(void)
{
    CMock_Guts_MemFreeAll();
    memset(&Mock, 0, sizeof(Mock));
}

osStatus osKernelInitialize(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelInitialize_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelInitialize);
    cmock_call_instance = (CMOCK_osKernelInitialize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelInitialize_CallInstance);
    Mock.osKernelInitialize_CallInstance = CMock_Guts_MemNext(Mock.osKernelInitialize_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelInitialize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelInitialize_CALL_INSTANCE));
    CMOCK_osKernelInitialize_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelInitialize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelInitialize_CallInstance = CMock_Guts_MemChain(Mock.osKernelInitialize_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osKernelStart(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelStart_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelStart);
    cmock_call_instance = (CMOCK_osKernelStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelStart_CallInstance);
    Mock.osKernelStart_CallInstance = CMock_Guts_MemNext(Mock.osKernelStart_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelStart_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelStart_CALL_INSTANCE));
    CMOCK_osKernelStart_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelStart_CallInstance = CMock_Guts_MemChain(Mock.osKernelStart_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

int32_t osKernelRunning(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelRunning_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelRunning);
    cmock_call_instance = (CMOCK_osKernelRunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelRunning_CallInstance);
    Mock.osKernelRunning_CallInstance = CMock_Guts_MemNext(Mock.osKernelRunning_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelRunning_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelRunning_CALL_INSTANCE));
    CMOCK_osKernelRunning_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelRunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelRunning_CallInstance = CMock_Guts_MemChain(Mock.osKernelRunning_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t osKernelSysTick(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osKernelSysTick_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osKernelSysTick);
    cmock_call_instance = (CMOCK_osKernelSysTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osKernelSysTick_CallInstance);
    Mock.osKernelSysTick_CallInstance = CMock_Guts_MemNext(Mock.osKernelSysTick_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osKernelSysTick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osKernelSysTick_CALL_INSTANCE));
    CMOCK_osKernelSysTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_osKernelSysTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osKernelSysTick_CallInstance = CMock_Guts_MemChain(Mock.osKernelSysTick_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osThreadId osThreadCreate(const osThreadDef_t* thread_def, void* argument)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadCreate);
    cmock_call_instance = (CMOCK_osThreadCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadCreate_CallInstance);
    Mock.osThreadCreate_CallInstance = CMock_Guts_MemNext(Mock.osThreadCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadCreate, CMockString_thread_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_thread_def), (void*)(thread_def), sizeof(const osThreadDef_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadCreate, CMockString_argument);

        if (cmock_call_instance->Expected_argument == NULL)
        {
            UNITY_TEST_ASSERT_NULL(argument, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_argument, argument, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadCreate(CMOCK_osThreadCreate_CALL_INSTANCE* cmock_call_instance, const osThreadDef_t* thread_def, void* argument)
{
    cmock_call_instance->Expected_thread_def = thread_def;
    cmock_call_instance->Expected_argument = argument;
}

void osThreadCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osThreadDef_t* thread_def, void* argument, osThreadId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadCreate_CALL_INSTANCE));
    CMOCK_osThreadCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadCreate_CallInstance = CMock_Guts_MemChain(Mock.osThreadCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadCreate(cmock_call_instance, thread_def, argument);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadId[sizeof(cmock_to_return) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

osThreadId osThreadGetId(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetId_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetId);
    cmock_call_instance = (CMOCK_osThreadGetId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetId_CallInstance);
    Mock.osThreadGetId_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetId_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadGetId_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetId_CALL_INSTANCE));
    CMOCK_osThreadGetId_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetId_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetId_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetId_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadId[sizeof(cmock_to_return) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

osStatus osThreadTerminate(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadTerminate);
    cmock_call_instance = (CMOCK_osThreadTerminate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadTerminate_CallInstance);
    Mock.osThreadTerminate_CallInstance = CMock_Guts_MemNext(Mock.osThreadTerminate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadTerminate, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadTerminate(CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadTerminate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadTerminate_CALL_INSTANCE));
    CMOCK_osThreadTerminate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadTerminate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadTerminate_CallInstance = CMock_Guts_MemChain(Mock.osThreadTerminate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadTerminate(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadYield(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadYield_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadYield);
    cmock_call_instance = (CMOCK_osThreadYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadYield_CallInstance);
    Mock.osThreadYield_CallInstance = CMock_Guts_MemNext(Mock.osThreadYield_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadYield_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadYield_CALL_INSTANCE));
    CMOCK_osThreadYield_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadYield_CallInstance = CMock_Guts_MemChain(Mock.osThreadYield_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadSetPriority(osThreadId thread_id, osPriority priority)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadSetPriority);
    cmock_call_instance = (CMOCK_osThreadSetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadSetPriority_CallInstance);
    Mock.osThreadSetPriority_CallInstance = CMock_Guts_MemNext(Mock.osThreadSetPriority_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadSetPriority, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osThreadSetPriority, CMockString_priority);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_priority), (void*)(&priority), sizeof(osPriority), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadSetPriority(CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id, osPriority priority)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
    memcpy((void*)(&cmock_call_instance->Expected_priority), (void*)(&priority),
           sizeof(osPriority[sizeof(priority) == sizeof(osPriority) ? 1 : -1])); /* add osPriority to :treat_as_array if this causes an error */
}

void osThreadSetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osPriority priority, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadSetPriority_CALL_INSTANCE));
    CMOCK_osThreadSetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadSetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadSetPriority_CallInstance = CMock_Guts_MemChain(Mock.osThreadSetPriority_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadSetPriority(cmock_call_instance, thread_id, priority);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osPriority osThreadGetPriority(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetPriority);
    cmock_call_instance = (CMOCK_osThreadGetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetPriority_CallInstance);
    Mock.osThreadGetPriority_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetPriority_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetPriority, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetPriority(CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadGetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osPriority cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetPriority_CALL_INSTANCE));
    CMOCK_osThreadGetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetPriority_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetPriority_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetPriority(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osPriority[sizeof(cmock_to_return) == sizeof(osPriority) ? 1 : -1])); /* add osPriority to :treat_as_array if this causes an error */
}

osStatus osDelay(uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osDelay);
    cmock_call_instance = (CMOCK_osDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osDelay_CallInstance);
    Mock.osDelay_CallInstance = CMock_Guts_MemNext(Mock.osDelay_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osDelay, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osDelay(CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance, uint32_t millisec)
{
    cmock_call_instance->Expected_millisec = millisec;
}

void osDelay_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osDelay_CALL_INSTANCE));
    CMOCK_osDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_osDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osDelay_CallInstance = CMock_Guts_MemChain(Mock.osDelay_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osDelay(cmock_call_instance, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osEvent osWait(uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osWait);
    cmock_call_instance = (CMOCK_osWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osWait_CallInstance);
    Mock.osWait_CallInstance = CMock_Guts_MemNext(Mock.osWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osWait, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osWait(CMOCK_osWait_CALL_INSTANCE* cmock_call_instance, uint32_t millisec)
{
    cmock_call_instance->Expected_millisec = millisec;
}

void osWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t millisec, osEvent cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osWait_CALL_INSTANCE));
    CMOCK_osWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osWait_CallInstance = CMock_Guts_MemChain(Mock.osWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osWait(cmock_call_instance, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEvent[sizeof(cmock_to_return) == sizeof(osEvent) ? 1 : -1])); /* add osEvent to :treat_as_array if this causes an error */
}

osTimerId osTimerCreate(const osTimerDef_t* timer_def, os_timer_type type, void* argument)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerCreate);
    cmock_call_instance = (CMOCK_osTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerCreate_CallInstance);
    Mock.osTimerCreate_CallInstance = CMock_Guts_MemNext(Mock.osTimerCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerCreate, CMockString_timer_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_timer_def), (void*)(timer_def), sizeof(const osTimerDef_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerCreate, CMockString_type);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_type), (void*)(&type), sizeof(os_timer_type), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerCreate, CMockString_argument);

        if (cmock_call_instance->Expected_argument == NULL)
        {
            UNITY_TEST_ASSERT_NULL(argument, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_argument, argument, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerCreate(CMOCK_osTimerCreate_CALL_INSTANCE* cmock_call_instance, const osTimerDef_t* timer_def, os_timer_type type, void* argument)
{
    cmock_call_instance->Expected_timer_def = timer_def;
    memcpy((void*)(&cmock_call_instance->Expected_type), (void*)(&type),
           sizeof(os_timer_type[sizeof(type) == sizeof(os_timer_type) ? 1 : -1])); /* add os_timer_type to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_argument = argument;
}

void osTimerCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osTimerDef_t* timer_def, os_timer_type type, void* argument, osTimerId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerCreate_CALL_INSTANCE));
    CMOCK_osTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.osTimerCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerCreate(cmock_call_instance, timer_def, type, argument);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osTimerId[sizeof(cmock_to_return) == sizeof(osTimerId) ? 1 : -1])); /* add osTimerId to :treat_as_array if this causes an error */
}

osStatus osTimerStart(osTimerId timer_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerStart);
    cmock_call_instance = (CMOCK_osTimerStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerStart_CallInstance);
    Mock.osTimerStart_CallInstance = CMock_Guts_MemNext(Mock.osTimerStart_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerStart, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osTimerStart, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerStart(CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance, osTimerId timer_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId[sizeof(timer_id) == sizeof(osTimerId) ? 1 : -1])); /* add osTimerId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osTimerStart_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId timer_id, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerStart_CALL_INSTANCE));
    CMOCK_osTimerStart_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerStart_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerStart_CallInstance = CMock_Guts_MemChain(Mock.osTimerStart_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerStart(cmock_call_instance, timer_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osTimerStop(osTimerId timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerStop);
    cmock_call_instance = (CMOCK_osTimerStop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerStop_CallInstance);
    Mock.osTimerStop_CallInstance = CMock_Guts_MemNext(Mock.osTimerStop_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerStop, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerStop(CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance, osTimerId timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId[sizeof(timer_id) == sizeof(osTimerId) ? 1 : -1])); /* add osTimerId to :treat_as_array if this causes an error */
}

void osTimerStop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId timer_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerStop_CALL_INSTANCE));
    CMOCK_osTimerStop_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerStop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerStop_CallInstance = CMock_Guts_MemChain(Mock.osTimerStop_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerStop(cmock_call_instance, timer_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osTimerDelete(osTimerId timer_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osTimerDelete);
    cmock_call_instance = (CMOCK_osTimerDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osTimerDelete_CallInstance);
    Mock.osTimerDelete_CallInstance = CMock_Guts_MemNext(Mock.osTimerDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osTimerDelete, CMockString_timer_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id), sizeof(osTimerId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osTimerDelete(CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance, osTimerId timer_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_timer_id), (void*)(&timer_id),
           sizeof(osTimerId[sizeof(timer_id) == sizeof(osTimerId) ? 1 : -1])); /* add osTimerId to :treat_as_array if this causes an error */
}

void osTimerDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osTimerId timer_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osTimerDelete_CALL_INSTANCE));
    CMOCK_osTimerDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osTimerDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osTimerDelete_CallInstance = CMock_Guts_MemChain(Mock.osTimerDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osTimerDelete(cmock_call_instance, timer_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

int32_t osSignalSet(osThreadId thread_id, int32_t signals)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSignalSet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSignalSet);
    cmock_call_instance = (CMOCK_osSignalSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSignalSet_CallInstance);
    Mock.osSignalSet_CallInstance = CMock_Guts_MemNext(Mock.osSignalSet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSignalSet, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSignalSet, CMockString_signals);
        UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_signals, signals, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSignalSet(CMOCK_osSignalSet_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id, int32_t signals)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_signals = signals;
}

void osSignalSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, int32_t signals, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSignalSet_CALL_INSTANCE));
    CMOCK_osSignalSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSignalSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSignalSet_CallInstance = CMock_Guts_MemChain(Mock.osSignalSet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSignalSet(cmock_call_instance, thread_id, signals);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

int32_t osSignalClear(osThreadId thread_id, int32_t signals)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSignalClear_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSignalClear);
    cmock_call_instance = (CMOCK_osSignalClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSignalClear_CallInstance);
    Mock.osSignalClear_CallInstance = CMock_Guts_MemNext(Mock.osSignalClear_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSignalClear, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSignalClear, CMockString_signals);
        UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_signals, signals, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSignalClear(CMOCK_osSignalClear_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id, int32_t signals)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_signals = signals;
}

void osSignalClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, int32_t signals, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSignalClear_CALL_INSTANCE));
    CMOCK_osSignalClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSignalClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSignalClear_CallInstance = CMock_Guts_MemChain(Mock.osSignalClear_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSignalClear(cmock_call_instance, thread_id, signals);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osEvent osSignalWait(int32_t signals, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSignalWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSignalWait);
    cmock_call_instance = (CMOCK_osSignalWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSignalWait_CallInstance);
    Mock.osSignalWait_CallInstance = CMock_Guts_MemNext(Mock.osSignalWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSignalWait, CMockString_signals);
        UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_signals, signals, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSignalWait, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSignalWait(CMOCK_osSignalWait_CALL_INSTANCE* cmock_call_instance, int32_t signals, uint32_t millisec)
{
    cmock_call_instance->Expected_signals = signals;
    cmock_call_instance->Expected_millisec = millisec;
}

void osSignalWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t signals, uint32_t millisec, osEvent cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSignalWait_CALL_INSTANCE));
    CMOCK_osSignalWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSignalWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSignalWait_CallInstance = CMock_Guts_MemChain(Mock.osSignalWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSignalWait(cmock_call_instance, signals, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEvent[sizeof(cmock_to_return) == sizeof(osEvent) ? 1 : -1])); /* add osEvent to :treat_as_array if this causes an error */
}

osMutexId osMutexCreate(const osMutexDef_t* mutex_def)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexCreate);
    cmock_call_instance = (CMOCK_osMutexCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexCreate_CallInstance);
    Mock.osMutexCreate_CallInstance = CMock_Guts_MemNext(Mock.osMutexCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexCreate, CMockString_mutex_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mutex_def), (void*)(mutex_def), sizeof(const osMutexDef_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexCreate(CMOCK_osMutexCreate_CALL_INSTANCE* cmock_call_instance, const osMutexDef_t* mutex_def)
{
    cmock_call_instance->Expected_mutex_def = mutex_def;
}

void osMutexCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osMutexDef_t* mutex_def, osMutexId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexCreate_CALL_INSTANCE));
    CMOCK_osMutexCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexCreate_CallInstance = CMock_Guts_MemChain(Mock.osMutexCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexCreate(cmock_call_instance, mutex_def);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMutexId[sizeof(cmock_to_return) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
}

osStatus osMutexWait(osMutexId mutex_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexWait);
    cmock_call_instance = (CMOCK_osMutexWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexWait_CallInstance);
    Mock.osMutexWait_CallInstance = CMock_Guts_MemNext(Mock.osMutexWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexWait, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMutexWait, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexWait(CMOCK_osMutexWait_CALL_INSTANCE* cmock_call_instance, osMutexId mutex_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId[sizeof(mutex_id) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMutexWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId mutex_id, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexWait_CALL_INSTANCE));
    CMOCK_osMutexWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexWait_CallInstance = CMock_Guts_MemChain(Mock.osMutexWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexWait(cmock_call_instance, mutex_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osMutexRelease(osMutexId mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexRelease);
    cmock_call_instance = (CMOCK_osMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexRelease_CallInstance);
    Mock.osMutexRelease_CallInstance = CMock_Guts_MemNext(Mock.osMutexRelease_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexRelease, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexRelease(CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance, osMutexId mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId[sizeof(mutex_id) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
}

void osMutexRelease_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId mutex_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexRelease_CALL_INSTANCE));
    CMOCK_osMutexRelease_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexRelease_CallInstance = CMock_Guts_MemChain(Mock.osMutexRelease_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexRelease(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osMutexDelete(osMutexId mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMutexDelete);
    cmock_call_instance = (CMOCK_osMutexDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMutexDelete_CallInstance);
    Mock.osMutexDelete_CallInstance = CMock_Guts_MemNext(Mock.osMutexDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMutexDelete, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMutexDelete(CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance, osMutexId mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId[sizeof(mutex_id) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
}

void osMutexDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId mutex_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMutexDelete_CALL_INSTANCE));
    CMOCK_osMutexDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMutexDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMutexDelete_CallInstance = CMock_Guts_MemChain(Mock.osMutexDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMutexDelete(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osSemaphoreId osSemaphoreCreate(const osSemaphoreDef_t* semaphore_def, int32_t count)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreCreate);
    cmock_call_instance = (CMOCK_osSemaphoreCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreCreate_CallInstance);
    Mock.osSemaphoreCreate_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreCreate, CMockString_semaphore_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_semaphore_def), (void*)(semaphore_def), sizeof(const osSemaphoreDef_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreCreate, CMockString_count);
        UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_count, count, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreCreate(CMOCK_osSemaphoreCreate_CALL_INSTANCE* cmock_call_instance, const osSemaphoreDef_t* semaphore_def, int32_t count)
{
    cmock_call_instance->Expected_semaphore_def = semaphore_def;
    cmock_call_instance->Expected_count = count;
}

void osSemaphoreCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osSemaphoreDef_t* semaphore_def, int32_t count, osSemaphoreId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreCreate_CALL_INSTANCE));
    CMOCK_osSemaphoreCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreCreate_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreCreate(cmock_call_instance, semaphore_def, count);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osSemaphoreId[sizeof(cmock_to_return) == sizeof(osSemaphoreId) ? 1 : -1])); /* add osSemaphoreId to :treat_as_array if this causes an error */
}

int32_t osSemaphoreWait(osSemaphoreId semaphore_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreWait);
    cmock_call_instance = (CMOCK_osSemaphoreWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreWait_CallInstance);
    Mock.osSemaphoreWait_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreWait, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreWait, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreWait(CMOCK_osSemaphoreWait_CALL_INSTANCE* cmock_call_instance, osSemaphoreId semaphore_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId[sizeof(semaphore_id) == sizeof(osSemaphoreId) ? 1 : -1])); /* add osSemaphoreId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osSemaphoreWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId semaphore_id, uint32_t millisec, int32_t cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreWait_CALL_INSTANCE));
    CMOCK_osSemaphoreWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreWait_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreWait(cmock_call_instance, semaphore_id, millisec);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus osSemaphoreRelease(osSemaphoreId semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreRelease);
    cmock_call_instance = (CMOCK_osSemaphoreRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreRelease_CallInstance);
    Mock.osSemaphoreRelease_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreRelease_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreRelease, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreRelease(CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance, osSemaphoreId semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId[sizeof(semaphore_id) == sizeof(osSemaphoreId) ? 1 : -1])); /* add osSemaphoreId to :treat_as_array if this causes an error */
}

void osSemaphoreRelease_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId semaphore_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreRelease_CALL_INSTANCE));
    CMOCK_osSemaphoreRelease_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreRelease_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreRelease_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreRelease(cmock_call_instance, semaphore_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osSemaphoreDelete(osSemaphoreId semaphore_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSemaphoreDelete);
    cmock_call_instance = (CMOCK_osSemaphoreDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSemaphoreDelete_CallInstance);
    Mock.osSemaphoreDelete_CallInstance = CMock_Guts_MemNext(Mock.osSemaphoreDelete_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osSemaphoreDelete, CMockString_semaphore_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id), sizeof(osSemaphoreId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osSemaphoreDelete(CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance, osSemaphoreId semaphore_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_semaphore_id), (void*)(&semaphore_id),
           sizeof(osSemaphoreId[sizeof(semaphore_id) == sizeof(osSemaphoreId) ? 1 : -1])); /* add osSemaphoreId to :treat_as_array if this causes an error */
}

void osSemaphoreDelete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osSemaphoreId semaphore_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSemaphoreDelete_CALL_INSTANCE));
    CMOCK_osSemaphoreDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSemaphoreDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSemaphoreDelete_CallInstance = CMock_Guts_MemChain(Mock.osSemaphoreDelete_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osSemaphoreDelete(cmock_call_instance, semaphore_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osPoolId osPoolCreate(const osPoolDef_t* pool_def)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osPoolCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osPoolCreate);
    cmock_call_instance = (CMOCK_osPoolCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osPoolCreate_CallInstance);
    Mock.osPoolCreate_CallInstance = CMock_Guts_MemNext(Mock.osPoolCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osPoolCreate, CMockString_pool_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pool_def), (void*)(pool_def), sizeof(const osPoolDef_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osPoolCreate(CMOCK_osPoolCreate_CALL_INSTANCE* cmock_call_instance, const osPoolDef_t* pool_def)
{
    cmock_call_instance->Expected_pool_def = pool_def;
}

void osPoolCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osPoolDef_t* pool_def, osPoolId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osPoolCreate_CALL_INSTANCE));
    CMOCK_osPoolCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osPoolCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osPoolCreate_CallInstance = CMock_Guts_MemChain(Mock.osPoolCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osPoolCreate(cmock_call_instance, pool_def);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osPoolId[sizeof(cmock_to_return) == sizeof(osPoolId) ? 1 : -1])); /* add osPoolId to :treat_as_array if this causes an error */
}

void* osPoolAlloc(osPoolId pool_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osPoolAlloc_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osPoolAlloc);
    cmock_call_instance = (CMOCK_osPoolAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osPoolAlloc_CallInstance);
    Mock.osPoolAlloc_CallInstance = CMock_Guts_MemNext(Mock.osPoolAlloc_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osPoolAlloc, CMockString_pool_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id), sizeof(osPoolId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osPoolAlloc(CMOCK_osPoolAlloc_CALL_INSTANCE* cmock_call_instance, osPoolId pool_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id),
           sizeof(osPoolId[sizeof(pool_id) == sizeof(osPoolId) ? 1 : -1])); /* add osPoolId to :treat_as_array if this causes an error */
}

void osPoolAlloc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osPoolId pool_id, void* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osPoolAlloc_CALL_INSTANCE));
    CMOCK_osPoolAlloc_CALL_INSTANCE* cmock_call_instance = (CMOCK_osPoolAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osPoolAlloc_CallInstance = CMock_Guts_MemChain(Mock.osPoolAlloc_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osPoolAlloc(cmock_call_instance, pool_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

void* osPoolCAlloc(osPoolId pool_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osPoolCAlloc_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osPoolCAlloc);
    cmock_call_instance = (CMOCK_osPoolCAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osPoolCAlloc_CallInstance);
    Mock.osPoolCAlloc_CallInstance = CMock_Guts_MemNext(Mock.osPoolCAlloc_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osPoolCAlloc, CMockString_pool_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id), sizeof(osPoolId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osPoolCAlloc(CMOCK_osPoolCAlloc_CALL_INSTANCE* cmock_call_instance, osPoolId pool_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id),
           sizeof(osPoolId[sizeof(pool_id) == sizeof(osPoolId) ? 1 : -1])); /* add osPoolId to :treat_as_array if this causes an error */
}

void osPoolCAlloc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osPoolId pool_id, void* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osPoolCAlloc_CALL_INSTANCE));
    CMOCK_osPoolCAlloc_CALL_INSTANCE* cmock_call_instance = (CMOCK_osPoolCAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osPoolCAlloc_CallInstance = CMock_Guts_MemChain(Mock.osPoolCAlloc_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osPoolCAlloc(cmock_call_instance, pool_id);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus osPoolFree(osPoolId pool_id, void* block)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osPoolFree_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osPoolFree);
    cmock_call_instance = (CMOCK_osPoolFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osPoolFree_CallInstance);
    Mock.osPoolFree_CallInstance = CMock_Guts_MemNext(Mock.osPoolFree_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osPoolFree, CMockString_pool_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id), sizeof(osPoolId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osPoolFree, CMockString_block);

        if (cmock_call_instance->Expected_block == NULL)
        {
            UNITY_TEST_ASSERT_NULL(block, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_block, block, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osPoolFree(CMOCK_osPoolFree_CALL_INSTANCE* cmock_call_instance, osPoolId pool_id, void* block)
{
    memcpy((void*)(&cmock_call_instance->Expected_pool_id), (void*)(&pool_id),
           sizeof(osPoolId[sizeof(pool_id) == sizeof(osPoolId) ? 1 : -1])); /* add osPoolId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_block = block;
}

void osPoolFree_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osPoolId pool_id, void* block, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osPoolFree_CALL_INSTANCE));
    CMOCK_osPoolFree_CALL_INSTANCE* cmock_call_instance = (CMOCK_osPoolFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osPoolFree_CallInstance = CMock_Guts_MemChain(Mock.osPoolFree_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osPoolFree(cmock_call_instance, pool_id, block);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osMessageQId osMessageCreate(const osMessageQDef_t* queue_def, osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageCreate);
    cmock_call_instance = (CMOCK_osMessageCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageCreate_CallInstance);
    Mock.osMessageCreate_CallInstance = CMock_Guts_MemNext(Mock.osMessageCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageCreate, CMockString_queue_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_queue_def), (void*)(queue_def), sizeof(const osMessageQDef_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageCreate, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageCreate(CMOCK_osMessageCreate_CALL_INSTANCE* cmock_call_instance, const osMessageQDef_t* queue_def, osThreadId thread_id)
{
    cmock_call_instance->Expected_queue_def = queue_def;
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osMessageCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osMessageQDef_t* queue_def, osThreadId thread_id, osMessageQId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageCreate_CALL_INSTANCE));
    CMOCK_osMessageCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageCreate_CallInstance = CMock_Guts_MemChain(Mock.osMessageCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageCreate(cmock_call_instance, queue_def, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMessageQId[sizeof(cmock_to_return) == sizeof(osMessageQId) ? 1 : -1])); /* add osMessageQId to :treat_as_array if this causes an error */
}

osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessagePut_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessagePut);
    cmock_call_instance = (CMOCK_osMessagePut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessagePut_CallInstance);
    Mock.osMessagePut_CallInstance = CMock_Guts_MemNext(Mock.osMessagePut_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessagePut, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMessageQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessagePut, CMockString_info);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_info, info, cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessagePut, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessagePut(CMOCK_osMessagePut_CALL_INSTANCE* cmock_call_instance, osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMessageQId[sizeof(queue_id) == sizeof(osMessageQId) ? 1 : -1])); /* add osMessageQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_info = info;
    cmock_call_instance->Expected_millisec = millisec;
}

void osMessagePut_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQId queue_id, uint32_t info, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessagePut_CALL_INSTANCE));
    CMOCK_osMessagePut_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessagePut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessagePut_CallInstance = CMock_Guts_MemChain(Mock.osMessagePut_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessagePut(cmock_call_instance, queue_id, info, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessageGet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessageGet);
    cmock_call_instance = (CMOCK_osMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessageGet_CallInstance);
    Mock.osMessageGet_CallInstance = CMock_Guts_MemNext(Mock.osMessageGet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessageGet, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMessageQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessageGet, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessageGet(CMOCK_osMessageGet_CALL_INSTANCE* cmock_call_instance, osMessageQId queue_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMessageQId[sizeof(queue_id) == sizeof(osMessageQId) ? 1 : -1])); /* add osMessageQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMessageGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQId queue_id, uint32_t millisec, osEvent cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessageGet_CALL_INSTANCE));
    CMOCK_osMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessageGet_CallInstance = CMock_Guts_MemChain(Mock.osMessageGet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessageGet(cmock_call_instance, queue_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEvent[sizeof(cmock_to_return) == sizeof(osEvent) ? 1 : -1])); /* add osEvent to :treat_as_array if this causes an error */
}

osMailQId osMailCreate(const osMailQDef_t* queue_def, osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailCreate);
    cmock_call_instance = (CMOCK_osMailCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailCreate_CallInstance);
    Mock.osMailCreate_CallInstance = CMock_Guts_MemNext(Mock.osMailCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailCreate, CMockString_queue_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_queue_def), (void*)(queue_def), sizeof(const osMailQDef_t), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailCreate, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailCreate(CMOCK_osMailCreate_CALL_INSTANCE* cmock_call_instance, const osMailQDef_t* queue_def, osThreadId thread_id)
{
    cmock_call_instance->Expected_queue_def = queue_def;
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osMailCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osMailQDef_t* queue_def, osThreadId thread_id, osMailQId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailCreate_CALL_INSTANCE));
    CMOCK_osMailCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailCreate_CallInstance = CMock_Guts_MemChain(Mock.osMailCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailCreate(cmock_call_instance, queue_def, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMailQId[sizeof(cmock_to_return) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
}

void* osMailAlloc(osMailQId queue_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailAlloc_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailAlloc);
    cmock_call_instance = (CMOCK_osMailAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailAlloc_CallInstance);
    Mock.osMailAlloc_CallInstance = CMock_Guts_MemNext(Mock.osMailAlloc_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailAlloc, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMailQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailAlloc, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailAlloc(CMOCK_osMailAlloc_CALL_INSTANCE* cmock_call_instance, osMailQId queue_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMailQId[sizeof(queue_id) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMailAlloc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMailQId queue_id, uint32_t millisec, void* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailAlloc_CALL_INSTANCE));
    CMOCK_osMailAlloc_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailAlloc_CallInstance = CMock_Guts_MemChain(Mock.osMailAlloc_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailAlloc(cmock_call_instance, queue_id, millisec);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

void* osMailCAlloc(osMailQId queue_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailCAlloc_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailCAlloc);
    cmock_call_instance = (CMOCK_osMailCAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailCAlloc_CallInstance);
    Mock.osMailCAlloc_CallInstance = CMock_Guts_MemNext(Mock.osMailCAlloc_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailCAlloc, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMailQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailCAlloc, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailCAlloc(CMOCK_osMailCAlloc_CALL_INSTANCE* cmock_call_instance, osMailQId queue_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMailQId[sizeof(queue_id) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMailCAlloc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMailQId queue_id, uint32_t millisec, void* cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailCAlloc_CALL_INSTANCE));
    CMOCK_osMailCAlloc_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailCAlloc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailCAlloc_CallInstance = CMock_Guts_MemChain(Mock.osMailCAlloc_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailCAlloc(cmock_call_instance, queue_id, millisec);
    cmock_call_instance->ReturnVal = cmock_to_return;
}

osStatus osMailPut(osMailQId queue_id, void* mail)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailPut_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailPut);
    cmock_call_instance = (CMOCK_osMailPut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailPut_CallInstance);
    Mock.osMailPut_CallInstance = CMock_Guts_MemNext(Mock.osMailPut_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailPut, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMailQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailPut, CMockString_mail);

        if (cmock_call_instance->Expected_mail == NULL)
        {
            UNITY_TEST_ASSERT_NULL(mail, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mail, mail, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailPut(CMOCK_osMailPut_CALL_INSTANCE* cmock_call_instance, osMailQId queue_id, void* mail)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMailQId[sizeof(queue_id) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_mail = mail;
}

void osMailPut_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMailQId queue_id, void* mail, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailPut_CALL_INSTANCE));
    CMOCK_osMailPut_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailPut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailPut_CallInstance = CMock_Guts_MemChain(Mock.osMailPut_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailPut(cmock_call_instance, queue_id, mail);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osEvent osMailGet(osMailQId queue_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailGet_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailGet);
    cmock_call_instance = (CMOCK_osMailGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailGet_CallInstance);
    Mock.osMailGet_CallInstance = CMock_Guts_MemNext(Mock.osMailGet_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailGet, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMailQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailGet, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailGet(CMOCK_osMailGet_CALL_INSTANCE* cmock_call_instance, osMailQId queue_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMailQId[sizeof(queue_id) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMailGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMailQId queue_id, uint32_t millisec, osEvent cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailGet_CALL_INSTANCE));
    CMOCK_osMailGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailGet_CallInstance = CMock_Guts_MemChain(Mock.osMailGet_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailGet(cmock_call_instance, queue_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEvent[sizeof(cmock_to_return) == sizeof(osEvent) ? 1 : -1])); /* add osEvent to :treat_as_array if this causes an error */
}

osStatus osMailFree(osMailQId queue_id, void* mail)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMailFree_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMailFree);
    cmock_call_instance = (CMOCK_osMailFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMailFree_CallInstance);
    Mock.osMailFree_CallInstance = CMock_Guts_MemNext(Mock.osMailFree_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMailFree, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMailQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMailFree, CMockString_mail);

        if (cmock_call_instance->Expected_mail == NULL)
        {
            UNITY_TEST_ASSERT_NULL(mail, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mail, mail, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMailFree(CMOCK_osMailFree_CALL_INSTANCE* cmock_call_instance, osMailQId queue_id, void* mail)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMailQId[sizeof(queue_id) == sizeof(osMailQId) ? 1 : -1])); /* add osMailQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_mail = mail;
}

void osMailFree_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMailQId queue_id, void* mail, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMailFree_CALL_INSTANCE));
    CMOCK_osMailFree_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMailFree_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMailFree_CallInstance = CMock_Guts_MemChain(Mock.osMailFree_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMailFree(cmock_call_instance, queue_id, mail);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

void osSystickHandler(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osSystickHandler_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osSystickHandler);
    cmock_call_instance = (CMOCK_osSystickHandler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osSystickHandler_CallInstance);
    Mock.osSystickHandler_CallInstance = CMock_Guts_MemNext(Mock.osSystickHandler_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
}

void osSystickHandler_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osSystickHandler_CALL_INSTANCE));
    CMOCK_osSystickHandler_CALL_INSTANCE* cmock_call_instance = (CMOCK_osSystickHandler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osSystickHandler_CallInstance = CMock_Guts_MemChain(Mock.osSystickHandler_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
}

osThreadState osThreadGetState(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadGetState);
    cmock_call_instance = (CMOCK_osThreadGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadGetState_CallInstance);
    Mock.osThreadGetState_CallInstance = CMock_Guts_MemNext(Mock.osThreadGetState_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadGetState, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadGetState(CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadGetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osThreadState cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadGetState_CALL_INSTANCE));
    CMOCK_osThreadGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadGetState_CallInstance = CMock_Guts_MemChain(Mock.osThreadGetState_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadGetState(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osThreadState[sizeof(cmock_to_return) == sizeof(osThreadState) ? 1 : -1])); /* add osThreadState to :treat_as_array if this causes an error */
}

osStatus osThreadIsSuspended(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadIsSuspended_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadIsSuspended);
    cmock_call_instance = (CMOCK_osThreadIsSuspended_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadIsSuspended_CallInstance);
    Mock.osThreadIsSuspended_CallInstance = CMock_Guts_MemNext(Mock.osThreadIsSuspended_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadIsSuspended, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadIsSuspended(CMOCK_osThreadIsSuspended_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadIsSuspended_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadIsSuspended_CALL_INSTANCE));
    CMOCK_osThreadIsSuspended_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadIsSuspended_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadIsSuspended_CallInstance = CMock_Guts_MemChain(Mock.osThreadIsSuspended_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadIsSuspended(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadSuspend(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadSuspend);
    cmock_call_instance = (CMOCK_osThreadSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadSuspend_CallInstance);
    Mock.osThreadSuspend_CallInstance = CMock_Guts_MemNext(Mock.osThreadSuspend_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadSuspend, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadSuspend(CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadSuspend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadSuspend_CALL_INSTANCE));
    CMOCK_osThreadSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadSuspend_CallInstance = CMock_Guts_MemChain(Mock.osThreadSuspend_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadSuspend(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadResume(osThreadId thread_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadResume);
    cmock_call_instance = (CMOCK_osThreadResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadResume_CallInstance);
    Mock.osThreadResume_CallInstance = CMock_Guts_MemNext(Mock.osThreadResume_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadResume, CMockString_thread_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id), sizeof(osThreadId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadResume(CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance, osThreadId thread_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_thread_id), (void*)(&thread_id),
           sizeof(osThreadId[sizeof(thread_id) == sizeof(osThreadId) ? 1 : -1])); /* add osThreadId to :treat_as_array if this causes an error */
}

void osThreadResume_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osThreadId thread_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadResume_CALL_INSTANCE));
    CMOCK_osThreadResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadResume_CallInstance = CMock_Guts_MemChain(Mock.osThreadResume_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadResume(cmock_call_instance, thread_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadSuspendAll(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadSuspendAll_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadSuspendAll);
    cmock_call_instance = (CMOCK_osThreadSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadSuspendAll_CallInstance);
    Mock.osThreadSuspendAll_CallInstance = CMock_Guts_MemNext(Mock.osThreadSuspendAll_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadSuspendAll_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadSuspendAll_CALL_INSTANCE));
    CMOCK_osThreadSuspendAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadSuspendAll_CallInstance = CMock_Guts_MemChain(Mock.osThreadSuspendAll_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadResumeAll(void)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadResumeAll_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadResumeAll);
    cmock_call_instance = (CMOCK_osThreadResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadResumeAll_CallInstance);
    Mock.osThreadResumeAll_CallInstance = CMock_Guts_MemNext(Mock.osThreadResumeAll_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void osThreadResumeAll_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadResumeAll_CALL_INSTANCE));
    CMOCK_osThreadResumeAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadResumeAll_CallInstance = CMock_Guts_MemChain(Mock.osThreadResumeAll_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osDelayUntil(uint32_t* PreviousWakeTime, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osDelayUntil);
    cmock_call_instance = (CMOCK_osDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osDelayUntil_CallInstance);
    Mock.osDelayUntil_CallInstance = CMock_Guts_MemNext(Mock.osDelayUntil_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osDelayUntil, CMockString_PreviousWakeTime);

        if (cmock_call_instance->Expected_PreviousWakeTime == NULL)
        {
            UNITY_TEST_ASSERT_NULL(PreviousWakeTime, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_PreviousWakeTime, PreviousWakeTime, 1, cmock_line, CMockStringMismatch);
        }
    }
    {
        UNITY_SET_DETAILS(CMockString_osDelayUntil, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osDelayUntil(CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance, uint32_t* PreviousWakeTime, uint32_t millisec)
{
    cmock_call_instance->Expected_PreviousWakeTime = PreviousWakeTime;
    cmock_call_instance->Expected_millisec = millisec;
}

void osDelayUntil_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* PreviousWakeTime, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osDelayUntil_CALL_INSTANCE));
    CMOCK_osDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_osDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.osDelayUntil_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osDelayUntil(cmock_call_instance, PreviousWakeTime, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osThreadList(uint8_t* buffer)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osThreadList_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osThreadList);
    cmock_call_instance = (CMOCK_osThreadList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osThreadList_CallInstance);
    Mock.osThreadList_CallInstance = CMock_Guts_MemNext(Mock.osThreadList_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osThreadList, CMockString_buffer);

        if (cmock_call_instance->Expected_buffer == NULL)
        {
            UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL);
        }
        else
        {
            UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, 1, cmock_line, CMockStringMismatch);
        }
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osThreadList(CMOCK_osThreadList_CALL_INSTANCE* cmock_call_instance, uint8_t* buffer)
{
    cmock_call_instance->Expected_buffer = buffer;
}

void osThreadList_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* buffer, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osThreadList_CALL_INSTANCE));
    CMOCK_osThreadList_CALL_INSTANCE* cmock_call_instance = (CMOCK_osThreadList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osThreadList_CallInstance = CMock_Guts_MemChain(Mock.osThreadList_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osThreadList(cmock_call_instance, buffer);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osEvent osMessagePeek(osMessageQId queue_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osMessagePeek_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osMessagePeek);
    cmock_call_instance = (CMOCK_osMessagePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osMessagePeek_CallInstance);
    Mock.osMessagePeek_CallInstance = CMock_Guts_MemNext(Mock.osMessagePeek_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osMessagePeek, CMockString_queue_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id), sizeof(osMessageQId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osMessagePeek, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osMessagePeek(CMOCK_osMessagePeek_CALL_INSTANCE* cmock_call_instance, osMessageQId queue_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_queue_id), (void*)(&queue_id),
           sizeof(osMessageQId[sizeof(queue_id) == sizeof(osMessageQId) ? 1 : -1])); /* add osMessageQId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osMessagePeek_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMessageQId queue_id, uint32_t millisec, osEvent cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osMessagePeek_CALL_INSTANCE));
    CMOCK_osMessagePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_osMessagePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osMessagePeek_CallInstance = CMock_Guts_MemChain(Mock.osMessagePeek_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osMessagePeek(cmock_call_instance, queue_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osEvent[sizeof(cmock_to_return) == sizeof(osEvent) ? 1 : -1])); /* add osEvent to :treat_as_array if this causes an error */
}

osMutexId osRecursiveMutexCreate(const osMutexDef_t* mutex_def)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osRecursiveMutexCreate_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osRecursiveMutexCreate);
    cmock_call_instance = (CMOCK_osRecursiveMutexCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osRecursiveMutexCreate_CallInstance);
    Mock.osRecursiveMutexCreate_CallInstance = CMock_Guts_MemNext(Mock.osRecursiveMutexCreate_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osRecursiveMutexCreate, CMockString_mutex_def);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mutex_def), (void*)(mutex_def), sizeof(const osMutexDef_t), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osRecursiveMutexCreate(CMOCK_osRecursiveMutexCreate_CALL_INSTANCE* cmock_call_instance, const osMutexDef_t* mutex_def)
{
    cmock_call_instance->Expected_mutex_def = mutex_def;
}

void osRecursiveMutexCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const osMutexDef_t* mutex_def, osMutexId cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osRecursiveMutexCreate_CALL_INSTANCE));
    CMOCK_osRecursiveMutexCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_osRecursiveMutexCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osRecursiveMutexCreate_CallInstance = CMock_Guts_MemChain(Mock.osRecursiveMutexCreate_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osRecursiveMutexCreate(cmock_call_instance, mutex_def);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osMutexId[sizeof(cmock_to_return) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
}

osStatus osRecursiveMutexRelease(osMutexId mutex_id)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osRecursiveMutexRelease_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osRecursiveMutexRelease);
    cmock_call_instance = (CMOCK_osRecursiveMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osRecursiveMutexRelease_CallInstance);
    Mock.osRecursiveMutexRelease_CallInstance = CMock_Guts_MemNext(Mock.osRecursiveMutexRelease_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osRecursiveMutexRelease, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId), cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osRecursiveMutexRelease(CMOCK_osRecursiveMutexRelease_CALL_INSTANCE* cmock_call_instance, osMutexId mutex_id)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId[sizeof(mutex_id) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
}

void osRecursiveMutexRelease_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId mutex_id, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osRecursiveMutexRelease_CALL_INSTANCE));
    CMOCK_osRecursiveMutexRelease_CALL_INSTANCE* cmock_call_instance = (CMOCK_osRecursiveMutexRelease_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osRecursiveMutexRelease_CallInstance = CMock_Guts_MemChain(Mock.osRecursiveMutexRelease_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osRecursiveMutexRelease(cmock_call_instance, mutex_id);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

osStatus osRecursiveMutexWait(osMutexId mutex_id, uint32_t millisec)
{
    UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
    CMOCK_osRecursiveMutexWait_CALL_INSTANCE* cmock_call_instance;
    UNITY_SET_DETAIL(CMockString_osRecursiveMutexWait);
    cmock_call_instance = (CMOCK_osRecursiveMutexWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.osRecursiveMutexWait_CallInstance);
    Mock.osRecursiveMutexWait_CallInstance = CMock_Guts_MemNext(Mock.osRecursiveMutexWait_CallInstance);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
    cmock_line = cmock_call_instance->LineNumber;
    {
        UNITY_SET_DETAILS(CMockString_osRecursiveMutexWait, CMockString_mutex_id);
        UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id), sizeof(osMutexId), cmock_line, CMockStringMismatch);
    }
    {
        UNITY_SET_DETAILS(CMockString_osRecursiveMutexWait, CMockString_millisec);
        UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_millisec, millisec, cmock_line, CMockStringMismatch);
    }
    UNITY_CLR_DETAILS();
    return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_osRecursiveMutexWait(CMOCK_osRecursiveMutexWait_CALL_INSTANCE* cmock_call_instance, osMutexId mutex_id, uint32_t millisec)
{
    memcpy((void*)(&cmock_call_instance->Expected_mutex_id), (void*)(&mutex_id),
           sizeof(osMutexId[sizeof(mutex_id) == sizeof(osMutexId) ? 1 : -1])); /* add osMutexId to :treat_as_array if this causes an error */
    cmock_call_instance->Expected_millisec = millisec;
}

void osRecursiveMutexWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, osMutexId mutex_id, uint32_t millisec, osStatus cmock_to_return)
{
    CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_osRecursiveMutexWait_CALL_INSTANCE));
    CMOCK_osRecursiveMutexWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_osRecursiveMutexWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
    UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
    memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
    Mock.osRecursiveMutexWait_CallInstance = CMock_Guts_MemChain(Mock.osRecursiveMutexWait_CallInstance, cmock_guts_index);
    cmock_call_instance->LineNumber = cmock_line;
    CMockExpectParameters_osRecursiveMutexWait(cmock_call_instance, mutex_id, millisec);
    memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
           sizeof(osStatus[sizeof(cmock_to_return) == sizeof(osStatus) ? 1 : -1])); /* add osStatus to :treat_as_array if this causes an error */
}

